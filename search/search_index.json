{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Mouette is a small python library for handling point clouds, polylines, surface and volume meshes. It also contains various geometry processing algorithm, like shortest-paths,  surface parametrization or frame field smoothing.</p> <p>Mouette (French for seagull) stands for Maillages, OUtils Et Traitement auTomatique de la g\u00e9om\u00e9triE (French for \"Meshes, Tools and Geometry Processing).</p>"},{"location":"#overview","title":"Overview","text":""},{"location":"#creating-or-loading-geometry","title":"Creating or loading geometry","text":"<p>mouette supports four types of geometries: point clouds (dim 0), polylines (dim 1), surface meshes (dim 2) and volume meshes (dim 3).</p> <pre><code>import numpy as np\nimport mouette as M\n\n### From numpy arrays\nvertices = np.array([[0,0,0],[1,2,3],[1,-1,0],[0,1,-2]])\nfaces = np.array([[0,1,2], [0,1,3]])\nsurface1 = M.mesh.from_arrays(vertices,F=faces) # a simple quad\n\n### From files\nsurface2 = M.mesh.load(\"path/to/my/mesh/mesh.obj\")\n\n### From provided procedural functions\nsurface3 = M.procedural.torus(50,20)\n</code></pre> <p><code>mouette</code> supports a variety of file formats: </p> <ul> <li>wavefront (.obj)</li> <li>medit (.mesh)</li> <li>stl</li> <li>ply (only for input)</li> <li>off</li> <li>tet</li> <li>geogram (.geogram_ascii), see https://github.com/BrunoLevy/geogram</li> <li>xyz (for point clouds).</li> </ul>"},{"location":"#saving-a-mesh","title":"Saving a mesh","text":"<p>Data structures from <code>mouette</code> can be easily stored in various file formats using the <code>save</code> function:</p> <pre><code>M.mesh.save(my_mesh,\"path/to/export/mesh.obj\")\n</code></pre> <p>the extension given in the path determines the file format.</p>"},{"location":"#mesh-connectivity","title":"Mesh connectivity","text":"<p>Starting from the <code>Polyline</code> class, <code>mouette</code> implements various methods to query the adjacent elements of a given vertex, edge, face or cell:</p> <pre><code># list of vertices that are linked by an edge to vertex 42\nneighbors = my_mesh.connectivity.vertex_to_vertices(42) \n\n# list of faces in which vertex 42 is a vertex\nface_ring = my_mesh.connectivity.vertex_to_faces(42) \n</code></pre>"},{"location":"#manipulating-attributes","title":"Manipulating attributes","text":"<p>It is possible to define any quantity on mesh elements:</p> <pre><code># an attribute storing one floating-point number per vertex\nmy_v_attribute = mesh.vertices.create_attribute(\"my_attribute\", float) \nmy_v_attribute[3] = 4.\n\n# an attribute storing two integers per face\nmy_f_attribute = mesh.faces.create_attribute(\"my_attribute\", 2, int) \nm_f_attribute[2] = [1,3]\n</code></pre> <p>Attributes can store booleans, integers, floating-point numbers, complex numbers and strings, using the provided python types <code>bool</code>, <code>int</code>, <code>float</code>, <code>complex</code> and <code>str</code>.</p> <p>Mouette also implements classical quantities to be computed on a mesh as attributes in the <code>M.attributes</code>submodule:</p> <pre><code>degree = M.attributes.vertex_degree(mesh) # number of neighbors of each vertex\nlengths = M.attributes.edge_length(mesh) # length of each edge\nareas = M.attributes.face_area(mesh) # area of each face\nangles = M.attributes.corner_angles(mesh) # angle at each face corner\n</code></pre>"},{"location":"#apply-geometry-processing-algorithms","title":"Apply Geometry Processing Algorithms","text":"<p><code>mouette</code> implements some geometry processing algorithms to be applied to your data:</p> <pre><code># define a frame field on the vertices of the surface mesh\nff = M.processing.framefield.SurfaceFrameField(mesh, \"vertices\")\nff.run()\nffmesh = ff.export_as_mesh()\nM.mesh.save(ffmesh, \"framefield.mesh\")\n</code></pre> <p>Classical discrete operators on meshes, like the gradient or the cotan-Laplacian, are also defined:</p> <pre><code>G = M.operators.gradient(mesh)\nmy_fun = mesh.vertices.get_attribute(\"f\").as_array()\ngrad = G @ my_fun\n\nL = M.operators.laplacian(mesh, cotan=True)\nLf = L @ my_fun\n</code></pre>"},{"location":"config/","title":"Global Configuration Variables","text":""},{"location":"config/#mouette.config.complete_edges_from_faces","title":"<code>complete_edges_from_faces = True</code>  <code>module-attribute</code>","text":"<p>In most file formats, surface meshes are given as a set of vertices and a set of faces, since edges can be retrieved from faces. If this option is set to true, the edge set of the mesh will be constructed from the face information.</p>"},{"location":"config/#mouette.config.complete_faces_from_cells","title":"<code>complete_faces_from_cells = True</code>  <code>module-attribute</code>","text":"<p>In most file formats, volume meshes are given as a set of vertices and tetrahedra (cells). If this option is set to true, the face set of the mesh will be constructed from the cells information.</p>"},{"location":"config/#mouette.config.display_duplicate_attribute_warning","title":"<code>display_duplicate_attribute_warning = False</code>  <code>module-attribute</code>","text":"<p>When creating an attribute that already exists on a mesh, mouette prints a warning in the console and returns the attribute currently carrying this name. If this flag is set to True, no warning is printed.</p>"},{"location":"config/#mouette.config.export_edges_in_obj","title":"<code>export_edges_in_obj = True</code>  <code>module-attribute</code>","text":"<p>Whether to export edges as <code>l &lt;v&gt; &lt;v&gt;</code> fields in .obj file format</p>"},{"location":"config/#mouette.config.sort_neighborhoods","title":"<code>sort_neighborhoods = True</code>  <code>module-attribute</code>","text":"<p>If set to true, this will sort the corner connectivity arrays of a surface mesh, according to the computed half edges</p>"},{"location":"operators/","title":"Matrix operators","text":""},{"location":"operators/#connectivity-operators","title":"Connectivity operators","text":""},{"location":"operators/#mouette.operators.adjacency.adjacency_matrix","title":"<code>adjacency_matrix(mesh, weights='one')</code>","text":"<p>Computes and returns the adjacency matrix of a mesh, that is a (sparse) matrix M such that</p> <pre><code>M[i,j] = M[j,i] = weights[i,j] if (i,j) is an edge of the mesh\n\nM[i,j] = 0 otherwise\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh</p> required <code>weights</code> <code>str</code> <p>How to weight the edges of the matrix. Options are: - \"one\" : every edge is 1 - \"length\" : every edge has weight corresponding to its length - a custom dict edge_id:int -&gt; weight:float Defaults to \"one\".</p> <code>'one'</code> <p>Returns:</p> Type Description <code>coo_matrix</code> <p>scipy.sparse.coo_matrix</p>"},{"location":"operators/#mouette.operators.adjacency.vertex_to_edge_operator","title":"<code>vertex_to_edge_operator(mesh, oriented=False)</code>","text":"<p>Vertices to edges operator. Matrix M of size |V|x|E| where:</p> <pre><code>M[v,e] = 1 if and only if v is one extremity of edge e.\n\nif oriented is set, M[v,e] = -1 if v is the origin of the edge and 1 if it is the arrival.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh</p> required <code>oriented</code> <code>bool</code> <p>whether to consider oriented edge and signed values or not. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>csc_matrix</code> <p>scipy.sparse.csc_matrix</p>"},{"location":"operators/#mouette.operators.adjacency.vertex_to_face_operator","title":"<code>vertex_to_face_operator(mesh)</code>","text":"<p>Vertices to face operator. Matrix M of size |V| x |F| where:</p> <pre><code>M[v,f] = 1/len(f) if and only if v is one of the vertices of f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input surface mesh</p> required <p>Returns:</p> Type Description <code>csc_matrix</code> <p>scipy.sparse.csc_matrix</p> See also <p>mouette.attributes.interpolate_vertices_to_faces</p>"},{"location":"operators/#gradient-operator","title":"Gradient operator","text":"<pre><code>    G = M.operators.gradient(mesh)\n    my_fun = mesh.vertices.get_attribute(\"f\").as_array()\n    grad = G @ my_fun\n</code></pre> <p>Computes the gradient operator, i.e. a |F| x |V| matrix G such that for any scalar function f defined over vertices of a surface mesh, Gf is its gradient inside faces.</p> <p>Gf maps to each face of the mesh either a vector of \\(\\mathbb{R}^2\\) or a complex number representing the gradient vector inside this face in local base.</p> <p>See https://github.com/GCoiffier/mouette/blob/main/examples/gradient.py</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>The input mesh</p> required <code>conn</code> <code>SurfaceConnectionFaces</code> <p>Connection objects specifying local bases of faces.</p> required <code>as_complex</code> <code>bool</code> <p>whether the output is |F| complex values of 2|F| float values</p> <code>True</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Fails if the mesh is not a triangulation</p> <p>Returns:</p> Type Description <code>csc_matrix</code> <p>scipy.sparse.csc_matrix: Gradient operator</p>"},{"location":"operators/#laplacian-operators","title":"Laplacian operators","text":"<p>https://en.wikipedia.org/wiki/Discrete_Laplace_operator#Mesh_Laplacians</p> <p>We refer to this course for a great overview of the Laplacian operator and its use in geometry processing.</p> <p>For the generalization to volumes, see this pdf</p>"},{"location":"operators/#example","title":"Example","text":"<pre><code>import mouette as M\nimport numpy as np\n\nmesh = M.mesh.load(\"path/to/my/mesh/mesh.obj\")\nW = M.operators.laplacian(mesh,cotan=True)\nA = M.operators.area_weight_matrix(mesh, inverse=True)\nL = A @ W # discretization of the laplace-beltrami operator is inverted mass matrix times the cotan weight matrix\nX = np.random.random(len(mesh.vertices)) # a value in (0,1) per vertex\nfor _ in range(10):\n    X = W.dot(X) # perform 10 steps of diffusion\n</code></pre>"},{"location":"operators/#mouette.operators.laplacian_op.graph_laplacian","title":"<code>graph_laplacian(mesh)</code>","text":"<p>Simplest Laplacian defined on a graph. uses uniform weights for connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh</p> required <p>Returns:</p> Type Description <code>csc_matrix</code> <p>(scipy.sparse.coo_matrix) : the laplacian operator as a sparse matrix</p>"},{"location":"operators/#mouette.operators.laplacian_op.laplacian","title":"<code>laplacian(mesh, cotan=True, connection=None, order=4)</code>","text":"<p>Cotan laplacian on vertices.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <code>cotan (bool) </code> <p>whether to compute real cotan values for more precise discretization or only 0/1 values as a graph laplacian. Defaults to True.</p> required <code>connection</code> <code>SurfaceConnectionVertices</code> <p>For a laplacian on 1-forms, gives the angle in local bases of all adjacent edges. Defaults to None.</p> <code>None</code> <code>order</code> <code>int</code> <p>Order of the parallel transport (useful when computing frame fields). Does nothing if connection is set to None. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>csc_matrix</code> <p>scipy.sparse.csc_matrix : the Laplacian operator as a sparse matrix</p>"},{"location":"operators/#mouette.operators.laplacian_op.laplacian_triangles","title":"<code>laplacian_triangles(mesh, cotan=True, connection=None, order=4)</code>","text":"<p>Cotan laplacian defined on face connectivity (ie on the dual mesh)</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh</p> required <code>cotan</code> <code>bool</code> <p>whether to use cotangents as weights. Defaults to True.</p> <code>True</code> <code>connection</code> <code>SurfaceConnectionFaces</code> <p>The surface connection describing local bases and parallel transport for a Laplacian that acts on vectors in tangent spaces. Defaults to None (scalar Laplacian).</p> <code>None</code> <code>order</code> <code>int</code> <p>Order of the parallel transport (useful when computing frame fields). Does nothing if connection is set to None. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>lil_matrix</code> <p>scipy.sparse.lil_matrix : the Laplacian operator as a sparse matrix</p>"},{"location":"operators/#mouette.operators.laplacian_op.volume_laplacian","title":"<code>volume_laplacian(mesh)</code>","text":"<p>Volume laplacian on vertices</p> <p>This is the 3D extension of the cotan laplacian, ie the discretization of the Laplace-Beltrami operator on 3D manifolds.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VolumeMesh</code> <p>the input mesh</p> required <p>Returns:</p> Type Description <code>lil_matrix</code> <p>scipy.sparse.lil_matrix: the Laplacian operator as a sparse matrix</p> References <p>[1] https://cseweb.ucsd.edu/~alchern/projects/ConformalVolume/</p> <p>[2] https://www.cs.cmu.edu/~kmcrane/Projects/Other/nDCotanFormula.pdf</p>"},{"location":"operators/#mouette.operators.laplacian_op.laplacian_tetrahedra","title":"<code>laplacian_tetrahedra(mesh)</code>","text":"<p>Laplacian defined on cell connectivity (ie on the dual volume mesh)</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <p>Returns:</p> Type Description <code>csc_matrix</code> <p>scipy.sparse.csc_matrix</p>"},{"location":"operators/#mouette.operators.laplacian_op.cotan_edge_diagonal","title":"<code>cotan_edge_diagonal(mesh, inverse=True)</code>","text":"<p>Builds a diagonal matrix of size |E|x|E| where the coefficients are the cotan weights, i.e.</p> <pre><code>M[e,e] = 1/abs( cot(a_e) + cot(b_e))\n</code></pre> <p>where a_e and b_e are the opposite angles in adjacent triangles of edge e.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <code>inverse</code> <code>bool</code> <p>whether to compute M or M^-1 (all coefficients on the diagonal inverted)</p> <code>True</code> <p>Returns:</p> Type Description <code>csc_matrix</code> <p>sp.csc_matrix</p>"},{"location":"visualizing/","title":"Visualize geometry with third party softwares","text":""},{"location":"visualizing/#graphite-3","title":"Graphite 3","text":"<p>https://github.com/BrunoLevy/GraphiteThree</p>"},{"location":"visualizing/#polyscope","title":"Polyscope","text":"<p>https://polyscope.run/py</p> <pre><code>import polyscope as ps\nimport mouette as M\nimport numpy as np\nbunny = M.mesh.load(\"bunny.obj\")\n\nps.init()\nV = np.asarray(bunny.vertices)\nF = np.asarray(bunny.faces)\nps.register_surface_mesh(\"bunny\", V, F)\nps.show()\n</code></pre>"},{"location":"about/dependencies/","title":"Dependencies","text":""},{"location":"about/dependencies/#numpy-and-scipy","title":"Numpy and Scipy","text":"<p>Mouette makes use of numpy arrays for storing data, as well as the scipy's sparse module</p>"},{"location":"about/dependencies/#numba","title":"Numba","text":"<p>Numba is a just-in-time compiler used for speeding up computations as well as making them parallel.</p>"},{"location":"about/dependencies/#osqp","title":"OSQP","text":"<p>OSQP( Operator Splitting Quadratic Program ) is a quadratic programming algorithm supporting linear equalities and inequalities as constraints. Mouette relies on this solver for least-square problems when linear constraints are involved.</p>"},{"location":"about/dependencies/#io-libraries","title":"IO libraries","text":"<ul> <li>stl-reader</li> <li>pyminiply</li> </ul>"},{"location":"about/dependencies/#misc","title":"Misc","text":"<ul> <li>aenum (better enumerations)</li> <li>tqdm (cool progress bars)</li> </ul>"},{"location":"about/installation/","title":"Installation","text":""},{"location":"about/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install mouette\n</code></pre>"},{"location":"about/installation/#from-sources","title":"From sources","text":"<pre><code>git clone https://github.com/GCoiffier/mouette.git\ncd mouette\npip3 install .\n</code></pre> <p>or, alternatively, run the <code>setup.py</code> script: <code>python3 setup.py</code></p>"},{"location":"about/license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2022 Guillaume Coiffier</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"algorithms/feature_detection/","title":"Surface Feature Detection","text":"<p>Detecting feature edges of a surface mesh is done in <code>mouette</code> in the <code>FeatureEdgeDetector</code> class. This class encapsulates various strategies of detection and stores the result for a given mesh.</p>"},{"location":"algorithms/feature_detection/#usage","title":"Usage","text":"<pre><code>fed = FeatureEdgeDetector([options])\nfed.detect(mesh)\n</code></pre> <p>or</p> <pre><code>fed = FeatureEdgeDetector([options])(mesh) # directly calls detect\n</code></pre> <p>This fills the various container attributes that can be accessed in the <code>FeatureEdgeDetector</code> class.</p> <p> </p> Feature edge detection on CAD models"},{"location":"algorithms/feature_detection/#mouette.processing.features.FeatureEdgeDetector","title":"<code>FeatureEdgeDetector(only_border=False, flag_corners=True, corner_order=4, compute_feature_graph=True, verbose=True)</code>","text":"<p>               Bases: <code>Worker</code></p> <p>Worker used to detect features on a surface mesh. Feature edges are of three types:</p> <ul> <li> <p>Marked edges from the input file (reading the \"hard_edges\" attribute on edges)</p> </li> <li> <p>Boundary edges</p> </li> <li> <p>Edges such that their dihedral angle is large (crease edges)</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>only_border</code> <code>bool</code> <p>If set to True, will only consider border edges as features. Defaults to False.</p> <code>False</code> <code>flag_corners</code> <code>bool</code> <p>If set to True, will also compute a goal angle defect (multiple of pi/2) of each detected vertices. Defaults to True.</p> <code>True</code> <code>corner_order</code> <code>int</code> <p>For corner detection, considers corners of angle defect 2pi/corner_order. Defaults to 4 (corners of pi/2).</p> <code>4</code> <code>compute_feature_graph</code> <code>bool</code> <p>whether to compute a Polyline object representing the feature graph and a point cloud representing the corners. For debug and visualization purposes. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Verbose mode. Defaults to True.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>feature_vertices</code> <code>set</code> <p>indices of the vertices that are adjacent to at least one feature edge</p> <code>feature_edges</code> <code>set</code> <p>indices of feature edges</p> <code>feature_degree</code> <code>Attribute</code> <p>number of feature edges each vertex is adjacent to</p> <code>local_feat_edges</code> <code>dict</code> <p>features edges in the neighborhood of each vertex (in the order of <code>mesh.connectivity.vertex_to_edges</code>)</p> <code>corners</code> <code>Attribute</code> <p>the order of each detected vertex corners</p>"},{"location":"algorithms/feature_detection/#mouette.processing.features.FeatureEdgeDetector.corner_point_cloud","title":"<code>corner_point_cloud</code>  <code>property</code>","text":"<p>Corners of the feature edges as a point cloud object</p> <p>Returns:</p> Name Type Description <code>PointCloud</code> <code>PointCloud</code> <p>Corners</p>"},{"location":"algorithms/feature_detection/#mouette.processing.features.FeatureEdgeDetector.feature_graph","title":"<code>feature_graph</code>  <code>property</code>","text":"<p>Feature edges as a polyline object</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the feature edges</p>"},{"location":"algorithms/feature_detection/#mouette.processing.features.FeatureEdgeDetector.clear","title":"<code>clear()</code>","text":"<p>Clears the data structures</p>"},{"location":"algorithms/feature_detection/#mouette.processing.features.FeatureEdgeDetector.detect","title":"<code>detect(mesh)</code>","text":"<p>Runs the detection on a provided mesh. Alias for <code>FeatureEdgeDetector.run(mesh)</code></p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required"},{"location":"algorithms/heat_method/","title":"The heat method for distance computation","text":"<p>Given a surface mesh, the heat method solves a heat diffusion problem to compute geodesic distances to prescribed source points.</p>"},{"location":"algorithms/heat_method/#usage","title":"Usage","text":"<pre><code>heat_solver = M.processing.HeatMethodDistance(mesh)\ndistance = heat_solver.get_distance(source_points_list)\n</code></pre> <p>See a full example here.</p> <p> </p> The distance from a point on the stanford bunny, computed using the heat method"},{"location":"algorithms/heat_method/#mouette.processing.heat_method.HeatMethodDistance","title":"<code>HeatMethodDistance(mesh, save_on_mesh=True, diffuse_coeff=1.0, verbose=False, **kwargs)</code>","text":"<p>               Bases: <code>Logger</code></p> <p>Computation of distances from a set of points on a surface mesh, using the heat method.</p> References <p>[1] The Heat Method for Distance Computation, Crane et al. (2017)</p> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/heat_method_distance.py</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>The input surface mesh</p> required <code>diffuse_coeff</code> <code>float</code> <p>Coefficient used in the diffusion computation of the heat. Higher coefficient leads to more regular but less precise results. This coefficient is multiplied by the mean edge length squared to account for global scaling. Defaults to 1.</p> <code>1.0</code> <code>verbose</code> <code>bool</code> <p>verbose output. Defaults to False.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>custom_connection</code> <code>SurfaceConnectionFaces</code> <p>custom local bases provided to the solver. If not provided, bases will be computed automatically. Defaults to None.</p> <p>Attributes:</p> Name Type Description <code>conn</code> <code>SurfaceConnectionFaces</code> <p>the local bases used to compute gradients and differential operators</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Fails if the input mesh is not triangular</p>"},{"location":"algorithms/heat_method/#mouette.processing.heat_method.HeatMethodDistance.get_distance","title":"<code>get_distance(source_points, return_gradients=False)</code>","text":"<p>Runs the heat method solve to compute distances to points given.</p> <p>Parameters:</p> Name Type Description Default <code>source_points</code> <code>list</code> <p>a list of points for which the distance will be zero.</p> required <code>return_gradients</code> <code>bool</code> <p>whether to also return gradients per face. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: a array of size |V| containing the distance to the source points for each vertex. If <code>return_gradients</code> is True, will also return the gradients as a complex value per face.</p>"},{"location":"algorithms/heat_method/#mouette.processing.heat_method.HeatMethodDistance.get_distance_to_boundary","title":"<code>get_distance_to_boundary(return_gradients=False)</code>","text":"<p>Computes the distance to the boundary for each vertex of the mesh.  A shortcut for <code>get_distance(mesh.boundary_vertices)</code></p> <p>Parameters:</p> Name Type Description Default <code>return_gradients</code> <code>bool</code> <p>whether to also return gradients per face. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Fails if the mesh has no boundary</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: a array of size |V| containing the distance to the source points for each vertex. If <code>return_gradients</code> is True, will also return the gradients as a complex value per face.</p>"},{"location":"algorithms/knn/","title":"Nearest Neighbors","text":""},{"location":"algorithms/knn/#mouette.spatial.kdtree.KDTree","title":"<code>KDTree(points, max_leaf_size=10, strategy='fast')</code>","text":"<p>Implementation of a kd-tree for space partitionning and fast nearest point queries.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>array of points (shape (N,d)) to consider. Can be of any dimension d, though the kd-tree algorithm have poor performance when the dimension grows.</p> required <code>max_leaf_size</code> <code>int</code> <p>Maximum number of points inside a leaf. Defaults to 10.</p> <code>10</code> <code>strategy</code> <code>str</code> <p>Node splitting strategy. Can be either 'fast', 'balanced' or 'random'. Defaults to \"fast\".</p> <code>'fast'</code> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the points are not of the correct (N,d) shape.</p>"},{"location":"algorithms/knn/#mouette.spatial.kdtree.KDTree.query","title":"<code>query(pt, k=1)</code>","text":"<p>Query the tree to find the k nearest neighbors of point 'pt'</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Vec</code> <p>the position to query</p> required <code>k</code> <code>int</code> <p>number of nearest points to query. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the indices of the k nearest points of 'pt' in increasing distance order</p>"},{"location":"algorithms/knn/#mouette.spatial.kdtree.KDTree.query_radius","title":"<code>query_radius(pt, r)</code>","text":"<p>Query the tree to find all points that are at distance &lt;= r from the position 'pt'.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Vec</code> <p>the position to query</p> required <code>r</code> <code>float</code> <p>radius of the query ball</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>all indices of points that are at distance at most r from the query point.</p>"},{"location":"algorithms/normal_estimation/","title":"Normal estimation for point clouds","text":""},{"location":"algorithms/normal_estimation/#usage","title":"Usage","text":"<pre><code>nrml_estimator = PointCloudNormalEstimator([options])\nnrml_estimation.run(mesh)\n</code></pre> <p>or</p> <pre><code>nrml_estimator = PointCloudNormalEstimator([options])(mesh) # directly calls run\n</code></pre> <p>This fills the various container attributes that can be accessed in the <code>PointCloudNormalEstimator</code> class.</p> <p> </p> Outward normal estimation on a point cloud of the spot model"},{"location":"algorithms/normal_estimation/#pointcloudnormalestimator","title":"PointCloudNormalEstimator","text":"<p>               Bases: <code>Worker</code></p> <p>An estimator of normal directions for unstructured point clouds, based on k-nearest neighbors and singular value decomposition of their correlation matrix.</p> References <p>[1] Surface reconstruction from unorganized points, Hoppe et al., 1992</p> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/point_cloud_normal_estimation.py</p> <p>Parameters:</p> Name Type Description Default <code>n_neighbors</code> <code>int</code> <p>number of neighbor points to consider for local plane fitting. Defaults to 5.</p> <code>5</code> <code>save_on_pc</code> <code>bool</code> <p>whether to store the resulting normals onto the point cloud as a vertex attribute, or as independent arrays. Defaults to True.</p> <code>True</code> <code>compute_curvature</code> <code>bool</code> <p>whether to also compute an estimate of curvature on the point cloud. This curvature estimate is computed as the ratio of the smallest eigenvalue and the sum of eigenvalues of the correlation matrix at each point (between 0 and 1). Defaults to False.</p> <code>False</code> <code>orientation_mode</code> <code>str</code> <p>Heuristic strategy for consistent orientation of normals. Choices are [\"None\", \"mst\"] Defaults to \"mst\".</p> <code>'mst'</code> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to True.</p> <code>True</code> <p>Other Parameters:</p> Name Type Description <code>normal_attribute_name</code> <code>str</code> <p>The name of the attribute in which normals are stored. Ignored if save_on_pc is set to False. Defaults to \"normals\".</p> <code>curvature_attribute_name</code> <code>str</code> <p>The name of the attribute in which the curvature estimation is stored. Ignored if save_on_pc is set to False. Defaults to \"curvature\".</p>"},{"location":"algorithms/shortest_paths/","title":"Shortest Paths","text":""},{"location":"algorithms/shortest_paths/#mouette.processing.paths.closest_n_vertices","title":"<code>closest_n_vertices(mesh, start, n, targets, weights='length', export_path_mesh=False)</code>","text":"<p>Computes a direct path to the first n vertices of the target list. Paths are the ones computed by BFS order, and are not garanteed to be the shortest. This is done so that traversal of the mesh remains local for performance purposes.</p> <p>If less than n vertices are provided in the list, will compute the shortest path to all provided targets.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh.</p> required <code>start</code> <code>int</code> <p>Vertex index of starting point in the mesh.</p> required <code>n</code> <code>int</code> required <code>targets</code> <code>list</code> <p>description</p> required <code>weights (str | dict | Attribute) </code> <p>provided weights of each edge. Options are: - \"one\" : uniform weight = 1 for every edge - \"length\" : use the length of the edge - any dict or Attribute on edges : custom weights weights are set to 0 for edges on the boundary. Defaults to \"length\".  </p> required <code>export_path_mesh</code> <code>bool</code> <p>If specified, will also return the path as a Polyline file. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Fails if the target list is empty</p>"},{"location":"algorithms/shortest_paths/#mouette.processing.paths.shortest_path","title":"<code>shortest_path(mesh, start, targets, weights='length', export_path_mesh=False)</code>","text":"<p>Computes the shortest path from 'start' vertex to all given targets. Uses Dijsktra's algorithm</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Polyline, SurfaceMesh, VolumeMesh]</code> <p>The mesh</p> required <code>start</code> <code>int</code> <p>Vertex index of starting point on the mesh</p> required <code>targets</code> <code>int | list | set</code> <p>Vertex index of the end point on the mesh or list of vertex indexes for ending points on the mesh</p> required <code>weights (str | dict) </code> <p>provided weights of each edge. Options are: - \"one\" : uniform weight = 1 for every edge - \"length\" : use the length of the edge - any dict : custom weights Defaults to \"length\".</p> required <code>export_path_mesh</code> <code>bool</code> <p>If specified, will also return the path as a Polyline file.  Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>target_id -&gt; list of vertices to visit on shortest path from 'start' to 'target_id'</p> <code>dict</code> <p>If export_path_mesh is set to True, also returns a Polyline</p>"},{"location":"algorithms/shortest_paths/#mouette.processing.paths.shortest_path_to_border","title":"<code>shortest_path_to_border(mesh, start, weights='length', export_path_mesh=False)</code>","text":"<p>Computes the shortest path from 'start' vertex to the boundary of the mesh. Call to shortest_path_to_vertex_set with the set of boundary vertices</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>The mesh</p> required <code>start</code> <code>int</code> <p>Vertex index of starting point on the mesh</p> required <code>weights (str | dict | Attribute) </code> <p>provided weights of each edge. Options are: - \"one\" : uniform weight = 1 for every edge - \"length\" : use the length of the edge - any dict or Attribute on edges : custom weights weights are set to 0 for edges on the boundary. Defaults to \"length\".</p> required <code>export_path_mesh</code> <code>bool</code> <p>If specified, will also return the path as a Polyline file.  Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>\"Mesh has no border\" raised if the border of the mesh does not exist</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The list of vertices on shortest path</p> <code>list</code> <p>If export_path_mesh is set to True, also returns a Polyline</p>"},{"location":"algorithms/shortest_paths/#mouette.processing.paths.shortest_path_to_vertex_set","title":"<code>shortest_path_to_vertex_set(mesh, start, targets, weights='length', export_path_mesh=False)</code>","text":"<p>Computes the shortest path from 'start' vertex to the closest vertex in the target set The idea is to add fictionnal edges between all vertices of targets to a representent vertex, with weight 0, and call Dijsktra's algorithm to reach this vertex.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Polyline, SurfaceMesh, VolumeMesh]</code> <p>The mesh</p> required <code>start</code> <code>int</code> <p>Vertex index of starting point on the mesh</p> required <code>targets</code> <code>list</code> <p>list of vertices to reach</p> required <code>weights (str | dict) </code> <p>provided weights of each edge. Options are: - \"one\" : uniform weight = 1 for every edge - \"length\" : use the length of the edge - any dict : custom weights Defaults to \"length\".</p> required <code>export_path_mesh</code> <code>bool</code> <p>If specified, will also return the path as a Polyline file.  Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Fails if the target list is empty</p> <p>Returns:</p> Name Type Description <code>int</code> <p>the index of the closest vertex from the targets set</p> <code>list</code> <p>the list of vertices on the closest path</p> <p>If export_path_mesh is set to True, also returns a Polyline</p>"},{"location":"algorithms/tree/","title":"Mesh Traversals","text":""},{"location":"algorithms/tree/#usage","title":"Usage","text":"<pre><code>data = M.mesh.load(\"my/super/data.mesh\")\n\ntree = M.processing.trees.EdgeSpanningTree(data)() # the () calls tree.compute()\nfor (parent,child) in tree.traverse():\n  print(parent,\"-&gt;\",child)\n</code></pre> Spanning trees of a disk mesh (left: EdgeSpanningTree, right: FaceSpanningTree)"},{"location":"algorithms/tree/#edgespanningtree","title":"EdgeSpanningTree","text":"<p>               Bases: <code>SpanningTree</code></p> <p>A spanning tree defined over the connectivity of a mesh. Edges of a polyline, surface mesh or volume mesh form an undirected graph, from which we can extract a spanning tree</p> Warning <p>This tree considers a unique starting point and stops when all reachable vertices are visited.  If the mesh is disconnected, the tree will be incomplete. In this case, use <code>EdgeSpanningForest</code> class instead.</p> <p>Attributes:</p> Name Type Description <code>parent</code> <code>list</code> <p>the list of indices of the parent node in the tree. <code>None</code> for the root.</p> <code>children</code> <code>list</code> <p>list of indices of children nodes.</p> <code>edges</code> <code>list</code> <p>list of edges that form the tree.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh (Polyline, Surface or Volume)</p> required <code>starting_vertex</code> <code>int</code> <p>Index of the root of the tree. If None is provided, root is chosen at random. Defaults to None.</p> <code>None</code> <code>avoid_boundary</code> <code>bool</code> <p>If True, boundary edges of a SurfaceMesh will not be traversed by the tree. Defaults to False.</p> <code>False</code> <code>avoid_edges</code> <code>set</code> <p>Set of edges that should not be travelled by the tree.  /!\\ If this set disconnects the mesh, the tree will be incomplete. Defaults to None.</p> <code>None</code>"},{"location":"algorithms/tree/#mouette.processing.trees.edge_sp.EdgeSpanningTree.build_tree_as_polyline","title":"<code>build_tree_as_polyline()</code>","text":"<p>Builds the tree as a new polyline object. Useful for debug and visualization purposes</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the tree</p>"},{"location":"algorithms/tree/#mouette.processing.trees.edge_sp.EdgeSpanningTree.traverse","title":"<code>traverse(order='BFS')</code>","text":"<p>Iterator on the nodes of a tree.  Returns tuple of form (node, parent)</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>BFS or DFS order. Defaults to \"BFS\".</p> <code>'BFS'</code>"},{"location":"algorithms/tree/#edgeminimalspanningtree","title":"EdgeMinimalSpanningTree","text":"<p>               Bases: <code>EdgeSpanningTree</code></p> <p>Same as EdgeSpanningTree but uses Kruskal's algorithm instead of a Breadth First Search. This implies that the resulting spanning tree is minimal in term of edge lengths.</p> <p>Inherits from <code>EdgeSpanningTree</code>.</p> Warning <p>This tree considers a unique starting point and stops when all reachable vertices are visited.  If the mesh is disconnected, the tree will be incomplete. In this case, use <code>EdgeSpanningForest</code> class instead.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh (Polyline, Surface or Volume)</p> required <code>starting_vertex</code> <code>int</code> <p>Index of the root of the tree. If None is provided, root is chosen at random. Defaults to None.</p> <code>None</code> <code>avoid_boundary</code> <code>bool</code> <p>If True, boundary edges will not be traversed by the tree. Defaults to False.</p> <code>False</code> <code>weights (str|dict, optional) </code> <p>provided weights of each edge. Options are: <code>one</code> : uniform weight = 1 for every edge; <code>length</code> : use the length of the edge; <code>any dict</code> : custom weights. Defaults to \"length\".</p> required"},{"location":"algorithms/tree/#mouette.processing.trees.edge_sp.EdgeMinimalSpanningTree.build_tree_as_polyline","title":"<code>build_tree_as_polyline()</code>","text":"<p>Builds the tree as a new polyline object. Useful for debug and visualization purposes</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the tree</p>"},{"location":"algorithms/tree/#mouette.processing.trees.edge_sp.EdgeMinimalSpanningTree.traverse","title":"<code>traverse(order='BFS')</code>","text":"<p>Iterator on the nodes of a tree.  Returns tuple of form (node, parent)</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>BFS or DFS order. Defaults to \"BFS\".</p> <code>'BFS'</code>"},{"location":"algorithms/tree/#edgespanningforest","title":"EdgeSpanningForest","text":"<p>               Bases: <code>SpanningForest</code></p> <p>A spanning forest that runs on edges.  Unlike a spanning tree, will create new roots and expand trees until all vertices of the mesh have been visited</p>"},{"location":"algorithms/tree/#mouette.processing.trees.edge_sp.EdgeSpanningForest.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>List of edges in the trees</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of edges</p>"},{"location":"algorithms/tree/#mouette.processing.trees.edge_sp.EdgeSpanningForest.n_trees","title":"<code>n_trees</code>  <code>property</code>","text":"<p>Number of trees in the forest</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code>"},{"location":"algorithms/tree/#mouette.processing.trees.edge_sp.EdgeSpanningForest.build_tree_as_polyline","title":"<code>build_tree_as_polyline()</code>","text":"<p>Builds the tree as a new polyline object. Useful for debug and visualization purposes</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the tree</p>"},{"location":"algorithms/tree/#mouette.processing.trees.edge_sp.EdgeSpanningForest.traverse","title":"<code>traverse(order='BFS')</code>","text":"<p>Iterator on the nodes of a tree </p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>BFS or DFS order. Defaults to \"BFS\".</p> <code>'BFS'</code>"},{"location":"algorithms/tree/#facespanningtree","title":"FaceSpanningTree","text":"<p>               Bases: <code>SpanningTree</code></p> <p>A spanning tree defined over the connectivity of a mesh, built over dual edges.</p> Warning <p>This tree considers a unique starting point and stops when all reachable faces are visited.  If the mesh is disconnected, the tree will be incomplete. In this case, use <code>FaceSpanningForest</code> class instead.</p>"},{"location":"algorithms/tree/#mouette.processing.trees.face_sp.FaceSpanningTree.build_tree_as_polyline","title":"<code>build_tree_as_polyline()</code>","text":"<p>Builds the tree as a new polyline object. Useful for debug and visualization purposes</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <p>the tree</p>"},{"location":"algorithms/tree/#mouette.processing.trees.face_sp.FaceSpanningTree.traverse","title":"<code>traverse(order='BFS')</code>","text":"<p>Iterator on the nodes of a tree.  Returns tuple of form (node, parent)</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>BFS or DFS order. Defaults to \"BFS\".</p> <code>'BFS'</code>"},{"location":"algorithms/tree/#facespanningforest","title":"FaceSpanningForest","text":"<p>               Bases: <code>SpanningForest</code></p> <p>A spanning forest that runs on dual edges. Unlike a spanning tree, will create new roots and expand trees until all faces of the mesh have been visited</p>"},{"location":"algorithms/tree/#mouette.processing.trees.face_sp.FaceSpanningForest.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>List of edges in the trees</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of edges</p>"},{"location":"algorithms/tree/#mouette.processing.trees.face_sp.FaceSpanningForest.n_trees","title":"<code>n_trees</code>  <code>property</code>","text":"<p>Number of trees in the forest</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code>"},{"location":"algorithms/tree/#mouette.processing.trees.face_sp.FaceSpanningForest.build_tree_as_polyline","title":"<code>build_tree_as_polyline()</code>","text":"<p>Builds the tree as a new polyline object. Useful for debug and visualization purposes</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the tree</p>"},{"location":"algorithms/tree/#mouette.processing.trees.face_sp.FaceSpanningForest.traverse","title":"<code>traverse(order='BFS')</code>","text":"<p>Iterator on the nodes of a tree </p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>BFS or DFS order. Defaults to \"BFS\".</p> <code>'BFS'</code>"},{"location":"algorithms/tree/#cellspanningtree","title":"CellSpanningTree","text":"<p>               Bases: <code>SpanningTree</code></p> <p>A spanning tree defined over the connectivity of a volume mesh.</p> Warning <p>This tree considers a unique starting point and stops when all reachable vertices are visited.  If the mesh is disconnected, the tree will be incomplete. In this case, use <code>CellSpanningForest</code> class instead.</p>"},{"location":"algorithms/tree/#mouette.processing.trees.cell_sp.CellSpanningTree.build_tree_as_polyline","title":"<code>build_tree_as_polyline()</code>","text":"<p>Builds the tree as a new polyline object. Useful for debug and visualization purposes</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the tree</p>"},{"location":"algorithms/tree/#mouette.processing.trees.cell_sp.CellSpanningTree.traverse","title":"<code>traverse(order='BFS')</code>","text":"<p>Iterator on the nodes of a tree.  Returns tuple of form (node, parent)</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>BFS or DFS order. Defaults to \"BFS\".</p> <code>'BFS'</code>"},{"location":"algorithms/tree/#cellspanningforest","title":"CellSpanningForest","text":"<p>               Bases: <code>SpanningForest</code></p> <p>A spanning forest that runs between cells.  Unlike a spanning tree, will create new roots and expand trees until all cells of the mesh have been visited</p>"},{"location":"algorithms/tree/#mouette.processing.trees.cell_sp.CellSpanningForest.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>List of edges in the trees</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of edges</p>"},{"location":"algorithms/tree/#mouette.processing.trees.cell_sp.CellSpanningForest.n_trees","title":"<code>n_trees</code>  <code>property</code>","text":"<p>Number of trees in the forest</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code>"},{"location":"algorithms/tree/#mouette.processing.trees.cell_sp.CellSpanningForest.build_tree_as_polyline","title":"<code>build_tree_as_polyline()</code>","text":"<p>Builds the tree as a new polyline object. Useful for debug and visualization purposes</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the tree</p>"},{"location":"algorithms/tree/#mouette.processing.trees.cell_sp.CellSpanningForest.traverse","title":"<code>traverse(order='BFS')</code>","text":"<p>Iterator on the nodes of a tree </p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>BFS or DFS order. Defaults to \"BFS\".</p> <code>'BFS'</code>"},{"location":"algorithms/frame_fields/","title":"Frame Fields","text":"<p>A frame field is a set of directions that live in the tangent space of a manifold. On a mesh, it can be represented as a set of vectors for each element (vertex/edge/face/cell) on which it is defined.</p> <p> </p> Smooth frame field on the bunny model and on a CAD mesh <p>A demo of mouette's surface frame field algorithms visualized in Polyscope can be found here</p>"},{"location":"algorithms/frame_fields/#the-framefield-base-class","title":"The FrameField base class","text":"<p>Mouette implements frame fields via the abstract base class <code>FrameField</code>. This base class is instanciated with various algorithms using higher level functions.</p>"},{"location":"algorithms/frame_fields/#framefield-smoothing","title":"Framefield smoothing","text":"<p>Given a <code>FrameField</code> object initialized by some external function, the user can run the smoothing algorithm using the <code>.run()</code> method. Alternatively, a <code>FrameField</code> object is callable:</p> <pre><code>ff.run() \nff() # produces similar results\n</code></pre>"},{"location":"algorithms/frame_fields/#variables-access","title":"Variables access","text":"<p><code>FrameField</code> objects are iterable. Indexing a frame field returns the representation of the frame at the given index. For 2D frame fields, this representation is a complex number. For 3D frame fields, it is a numpy array of shape (9,) representing the corresponding L4 spherical harmonics.</p> <pre><code>ff[7] # returns the representation of the frame for element (vertex/face/edge/cell)\n</code></pre>"},{"location":"algorithms/frame_fields/#singularity-flagging","title":"Singularity flagging","text":"<p>The <code>.flag_singularities()</code> method of the <code>FrameField</code> class allow to detect any singular point inside the frame field. When the boundary of the domain is constrained, those singularity points are bound to appear in 2D (due to the Poincar\u00e9-Hopf theorem). In 3D, the singularities are no longer ponctual, but form a network of lines called a singularity graph.</p>"},{"location":"algorithms/frame_fields/#export-and-visualization","title":"Export and Visualization","text":"<p>The <code>export_as_mesh()</code> method of the <code>FrameField</code> class outputs frames either as little crossed in 2D or little cubes in 3D for visualization purposes.</p>"},{"location":"algorithms/frame_fields/#frame-fields-in-mouette","title":"Frame fields in mouette","text":"<p><code>mouette</code> implements different kinds of frame fields:</p>"},{"location":"algorithms/frame_fields/#2d-frame-fields","title":"2D frame fields","text":"<ul> <li>Surface frame fields are orthogonal crosses on a surface mesh, either on its vertices, its edges or its faces</li> <li>Principal directions of curvature follow the eigenvectors of the approximated shape operator</li> </ul> <p>To work on curved surfaces, these frame field require the definition of a discrete surface connection which allows the comparison of elements in adjacent tangent spaces.</p>"},{"location":"algorithms/frame_fields/#3d-frame-fields","title":"3D frame fields","text":"<ul> <li>Volume frame fields are 3D crosses defined inside a volume mesh, either on its vertices or its cells.</li> </ul>"},{"location":"algorithms/frame_fields/connection/","title":"Discrete Connections","text":"<p>A connection is an object from differential geometry that maps between tangent planes. On a manifold, tangent planes are the local planar approximation of the surface. When comparing objects living in two adjacent planes, one must first align the plane and their corresponding bases. This can be done by parallel transporting objects from one plane to the other.</p> <p>On a surface mesh, this process is discrete and not differential. The parallel transport is then simply the angle formed by the two bases of the two planes.</p> <p>Interesting blog post on the topic: http://wordpress.discretization.de/geometryprocessingandapplicationsws19/connections-and-parallel-transport/</p>"},{"location":"algorithms/frame_fields/connection/#surfaceconnectionvertices","title":"SurfaceConnectionVertices","text":"<p>               Bases: <code>SurfaceConnection</code></p> <p>Local bases and parallel transport defined between tangent planes of the mesh at the vertices</p> Reference <p>Globally Optimal Direction Fields, Kn\u00f6ppel et al. (2013)</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh</p> required <code>feat</code> <code>FeatureEdgeDetector</code> <p>feature edges of the mesh. If not provided, will be initialized with a FeatureEdgeDetector object that flags only the boundary. Defaults to None.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>vnormals</code> <code>Attribute</code> <p>An attribute representing the vertex normals. If not provided, will be computed at initialization</p> <code>angles (Attribute) </code> <p>An attribute representing angles at corners of faces. If not provided, will be computed at initialization</p>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.connection.SurfaceConnectionVertices.bX","title":"<code>bX</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: local X vectors of bases as a 2D numpy array</p>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.connection.SurfaceConnectionVertices.bY","title":"<code>bY</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: local Y vectors of bases as a 2D numpy array</p>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.connection.SurfaceConnectionVertices.base","title":"<code>base(i)</code>","text":"<p>Local basis of element i</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>index</p> required <p>Returns:</p> Type Description <code>(Vec, Vec)</code> <p>the X vector and Y vector of the tangent basis.</p> Note <p><code>cross(X,Y)</code> is the normal of element i</p>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.connection.SurfaceConnectionVertices.transport","title":"<code>transport(iA, iB)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>iA</code> <code>int</code> <p>first vertex index</p> required <code>iB</code> <code>int</code> <p>second vertex index</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>angle needed to change from basis of iA to basis of iB</p>"},{"location":"algorithms/frame_fields/connection/#surfaceconnectionfaces","title":"SurfaceConnectionFaces","text":"<p>               Bases: <code>SurfaceConnection</code></p> <p>Local bases and parallel transport defined between tangent planes of the mesh at the vertices</p> Reference <p>Globally Optimal Direction Fields, Kn\u00f6ppel et al. (2013)</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh</p> required <code>feat</code> <code>FeatureEdgeDetector</code> <p>feature edges of the mesh. If not provided, will be initialized with a FeatureEdgeDetector object that flags only the boundary. Defaults to None.</p> <code>None</code>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.connection.SurfaceConnectionFaces.bX","title":"<code>bX</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: local X vectors of bases as a 2D numpy array</p>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.connection.SurfaceConnectionFaces.bY","title":"<code>bY</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: local Y vectors of bases as a 2D numpy array</p>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.connection.SurfaceConnectionFaces.base","title":"<code>base(i)</code>","text":"<p>Local basis of element i</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>index</p> required <p>Returns:</p> Type Description <code>(Vec, Vec)</code> <p>the X vector and Y vector of the tangent basis.</p> Note <p><code>cross(X,Y)</code> is the normal of element i</p>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.connection.SurfaceConnectionFaces.transport","title":"<code>transport(iA, iB)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>iA</code> <code>int</code> <p>first vertex index</p> required <code>iB</code> <code>int</code> <p>second vertex index</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>angle needed to change from basis of iA to basis of iB</p>"},{"location":"algorithms/frame_fields/connection/#discreteexponentialmap","title":"DiscreteExponentialMap","text":"<p>https://en.wikipedia.org/wiki/Exponential_map_(Riemannian_geometry)</p>"},{"location":"algorithms/frame_fields/connection/#usage","title":"Usage","text":"<pre><code>conn = SurfaceConnectionVertices(mesh)\nexpm = DiscreteExponentialMap(mesh, conn, rad)\nexpm.run({0, 2, 42}) # computes map for vertices 0, 2 and 42\n\nexpm.run() # computes map for all vertices\n\nu,v = expm.map(0, 3) # coordinates of vertex 3 in exp map of vertex 0\nu,v = expm.map(3, 0) # coordinates of vertex 0 in exp map of vertex 3. Exp map of 3 is computed on the go if necessary\n</code></pre> <p>               Bases: <code>Worker</code></p> References <ul> <li>[1] Interactive decal compositing with discrete exponential maps, Schmidt et al., 2006</li> </ul> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/expmap.py</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input surface mesh</p> required <code>conn</code> <code>SurfaceConnectionVertices</code> <p>connection over vertices for the mesh.</p> required <code>radius</code> <code>int</code> <p>Radius in number of edges of the exponential map of each vertex. Defaults to 2.</p> <code>2</code> <code>verbose</code> <code>bool</code> <p>verbose options. Defaults to False.</p> <code>False</code>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.expmap.DiscreteExponentialMap.export_map_as_mesh","title":"<code>export_map_as_mesh(v_source)</code>","text":"<p>Exports the map of vertex v_source as a flat surface mesh for visualization purposes </p> <p>Parameters:</p> Name Type Description Default <code>v_source</code> <code>int</code> <p>source vertex index</p> required <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>exponential map of v_source as a surface mesh</p>"},{"location":"algorithms/frame_fields/connection/#mouette.processing.expmap.DiscreteExponentialMap.map","title":"<code>map(v_source, v_target)</code>","text":"<p>Returns the uv-coordinates of v_target in the tangent plane of v_source. If the map of v_source was not computed, it is computed on the go.</p> <p>Parameters:</p> Name Type Description Default <code>v_source</code> <code>int</code> <p>target vertex index, center of the exponential map</p> required <code>v_target</code> <code>int</code> <p>query vertex index</p> required <p>Returns:</p> Name Type Description <code>Vec</code> <p>uv-coordinates of v_target as projected in the tangent plane of v_source. Returns None if v_target is not in the map of v_source (vertex is invalid or too far)</p>"},{"location":"algorithms/frame_fields/curvature/","title":"Directions of Curvature","text":"<p>The principal directions of curvature are the two tangent eigenvectors of the curvature tensor of a surface  (https://en.wikipedia.org/wiki/Principal_curvature). In practice, they are always orthogonal to each other and point towards the directions where curvature varies the fastest and the slowest.</p>"},{"location":"algorithms/frame_fields/curvature/#principaldirections","title":"PrincipalDirections","text":""},{"location":"algorithms/frame_fields/curvature/#usage","title":"Usage","text":"<pre><code>from mouette import framefield\nff = framefield.PrincipalDirections(mesh, \"vertices\", features=True, verbose=True, n_smooth=3)\nff.run()\nff.flag_singularities()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh onto which the framefield is based  </p> required <code>elements</code> <code>str</code> <p>\"vertices\" or \"faces\", the mesh elements onto which the frames live.  </p> required <p>Other Parameters:</p> Name Type Description <code>features</code> <code>bool</code> <p>Whether to consider feature edges or not. If no 'custom_features' argument is provided, features will be automatically detected (see the FeatureEdgeDetector class). Defaults to False.  </p> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.  </p> <code>n_smooth</code> <code>int</code> <p>Number of smoothing steps to perform. Defaults to 1.  </p> <code>smooth_attach_weight</code> <code>float</code> <p>Custom attach weight to previous solution during smoothing steps. If not provided, will be estimated at 1 for vertex version and 1e-3 for faces version. Defaults to None.  </p> <code>patch_size</code> <code>int</code> <p>On vertices only. Radius (in nubmer of edges) of the neighboring patch to be considered to approximate the shape operator. Defaults to 2.  </p> <code>confidence_threshold</code> <code>float</code> <p>Threshold on the anisotropy of the shape operator. Great anisotropy values (between 0 and 1) give good confidence on the principal directions. If the confidence is smaller than the threshold, eigenvectors will not be extracted and will instead be harmonically filled in. Defaults to 0.5.  </p> <code>smooth_threshold</code> <code>float</code> <p>Threshold on the anisotropy of the shape operator. Points with a confidence value higher than the threshold will be considered fixed during smoothing. Ignored is n_smooth is 0. Defaults to 0.7.  </p> <code>custom_connection</code> <code>SurfaceConnection</code> <p>custom connection object to be used for parallel transport. If not provided, a connection will be automatically computed (see SurfaceConnection class). Defaults to None.  </p> <code>custom_features</code> <code>FeatureEdgeDetector</code> <p>custom feature edges to be used in frame field optimization. If not provided, feature edges will be automatically detected. If the 'features' flag is set to False, features of this object are ignored. Defaults to None.  </p> <p>Returns:</p> Name Type Description <code>Framefield</code> <code>FrameField</code> <p>a frame field object representing the curvature directions</p> Note <p>Order of the frame field is fixed at 4 since principal curvature directions form an orthonormal basis.</p> References <ul> <li> <p>[1] https://en.wikipedia.org/wiki/Principal_curvature</p> </li> <li> <p>[2] Restricted Delaunay Triangulations and Normal Cycle, Cohen-Steiner and Morvan (2003)</p> </li> </ul> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/framefield2D.py</p>"},{"location":"algorithms/frame_fields/surface_ff/","title":"Surface Frame Fields","text":""},{"location":"algorithms/frame_fields/surface_ff/#surfaceframefield","title":"SurfaceFrameField","text":""},{"location":"algorithms/frame_fields/surface_ff/#usage","title":"Usage","text":"<pre><code>from mouette import framefield\nff = framefield.SurfaceFrameField(mesh, \"faces\", \n      order=4, features=True, \n      verbose=True, n_smooth=10, \n      smooth_attach_weight=0.2, \n      cad_correction=True)\n</code></pre> <p>Computes a smooth frame field on a surface mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh onto which the framefield is based</p> required <code>elements</code> <code>str</code> <p>\"vertices\", \"faces\" or \"edges\". The mesh elements onto which the frames live.</p> required <p>Other Parameters:</p> Name Type Description <code>order</code> <code>int</code> <p>Order of the frame field (number of branches). Defaults to 4.  </p> <code>features</code> <code>bool</code> <p>Whether to consider feature edges or not.  If no 'custom_features' argument is provided, features will be automatically detected (see the FeatureEdgeDetector class). Defaults to False.</p> <code>n_smooth</code> <code>int</code> <p>Number of smoothing steps to perform. Defaults to 3.  </p> <code>smooth_attach_weight</code> <code>float</code> <p>Custom attach weight to previous solution during smoothing steps.  If not provided, will be estimated automatically during optimization. Defaults to None.  </p> <code>use_cotan</code> <code>bool</code> <p>whether to use cotan for a better approximation of the Laplace-Beltrami operator. If False, will use a simple adjacency laplacian operator (See the operators module). Defaults to True.  </p> <code>cad_correction</code> <code>bool</code> <p>Whether to modify the parallel transport as in [2] to prevent singularities to appear close to pointy areas.  Will overwrite any connection provided with the 'custom_connection' argument. Defaults to True.  </p> <code>smooth_normals </code> <p>Whether to initialize the frame field as a mean of adjacent feature edges (True), or following one of the edges (False). has no effect for frame field on faces. Defaults to True.  </p> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.  </p> <code>singularity_indices</code> <code>Attribute</code> <p>custom singularity indices for the frame field. If provided, will use the algorithm described in [3] to get the smoothest frame field with these singularities. If elements is \"vertices\", the attribute should be indexed by the faces (where singularities appear) If elements is \"faces\", the attribute should be indexed by the vertices /!\\ Indices should respect the Poincarr\u00e9-Hopf theorem. Defaults to None.  </p> <code>custom_connection</code> <code>SurfaceConnection</code> <p>custom connection object to be used for parallel transport. If not provided, a connection will be automatically computed (see SurfaceConnection class). Defaults to None.</p> <code>custom_feature</code> <code>FeatureEdgeDetector</code> <p>custom feature edges to be used in frame field optimization. If not provided, feature edges will be automatically detected. If the 'features' flag is set to False, features of this object are ignored. Defaults to None.</p> <p>Raises:</p> Type Description <code>InvalidRangeArgumentError</code> <p>'order' should be &gt;= 1</p> <code>InvalidRangeArgumentError</code> <p>'n_smooth' should be &gt;= 0</p> <code>InvalidRangeArgumentError</code> <p>'smooth_attach_weight' should be &gt;= 0</p> <p>Returns:</p> Name Type Description <code>FrameField</code> <code>FrameField</code> <p>A framefield object with the correct specifications</p> References <ul> <li> <p>[1] An Approach to Quad Meshing Based on Harmonic Cross-Valued Maps and the Ginzburg-Landau Theory, Viertel and Osting (2018)</p> </li> <li> <p>[2] Frame Fields for CAD models, Desobry et al. (2022)</p> </li> <li> <p>[3] Trivial Connections on Discrete Surfaces, Crane et al. (2010)</p> </li> <li> <p>[4] Vector Field Processing on Triangle Meshes, de Goes et al., SIGGRAPH Courses (2016)</p> </li> <li> <p>[5] A Heat Method for Generalized Signed Distance, Feng and Crane (2024)</p> </li> </ul> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/framefield2D.py</p>"},{"location":"algorithms/frame_fields/volume_ff/","title":"Volume Frame Fields","text":""},{"location":"algorithms/frame_fields/volume_ff/#volumeframefields","title":"VolumeFrameFields","text":"<p>To represent the frames in a 3D frame field, we use the L4 Spherical Harmonics.</p>"},{"location":"algorithms/frame_fields/volume_ff/#usage","title":"Usage","text":"<pre><code>from mouette import framefield\nff = framefield.VolumeFrameField(mesh, \"vertices\", \n      features=True, n_smooth=10., \n      smooth_attach_weight=0.1, \n      verbose=True)\nff.run()\nff.flag_singularities()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VolumeMesh</code> <p>the supporting mesh</p> required <code>elements</code> <code>str</code> <p>\"vertices\" or \"cells\", the mesh elements onto which the frames live.</p> required <p>Other Parameters:</p> Name Type Description <code>features</code> <code>bool</code> <p>Whether to consider feature edges or not. Has no effect on the cell implementation. Defaults to True.</p> <code>n_smooth</code> <code>int</code> <p>Number of smoothing steps to perform. Defaults to 1.</p> <code>smooth_attach_weight</code> <code>float</code> <p>Custom attach weight to previous solution during smoothing steps.  If not provided, will be estimated automatically before optimization. Defaults to None.</p> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>custom_boundary_features</code> <code>FeatureEdgeDetector</code> <p>custom feature edges to be used in frame field optimization. If not provided, feature edges will be automatically detected. If the 'features' flag is set to False, features of this object are ignored. Has no effect on the cell implementation. Defaults to None.</p> <p>Returns:</p> Name Type Description <code>Framefield</code> <code>FrameField</code> <p>a frame field object with the correct settings</p> References <ul> <li>[1] Practical 3D frame field generation, Ray et al. (2016)</li> </ul> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/framefield3D.py</p>"},{"location":"algorithms/parametrization/","title":"Parametrization algorithms for surface meshes","text":""},{"location":"algorithms/parametrization/#conformal-maps","title":"Conformal maps","text":"<ul> <li> <p>Tutte's Embedding </p> </li> <li> <p>Least-Square Conformal Maps </p> </li> <li> <p>Boundary First Flattening </p> </li> </ul>"},{"location":"algorithms/parametrization/#injective-embeddings","title":"Injective embeddings:","text":"<ul> <li> <p>Foldover-free maps in 50 lines of code </p> </li> <li> <p>Cotangent Embedding </p> </li> </ul>"},{"location":"algorithms/parametrization/#global-parametrization","title":"Global Parametrization:","text":"<ul> <li> <p>Conformal Parametrization with cones </p> </li> <li> <p>Frame Field Integration </p> </li> </ul>"},{"location":"algorithms/parametrization/#misc","title":"Misc","text":"<ul> <li> <p>Surface cutting</p> </li> <li> <p>Measuring a mapping's distortion </p> </li> </ul>"},{"location":"algorithms/parametrization/Tutte/","title":"Tutte's Embedding","text":""},{"location":"algorithms/parametrization/Tutte/#usage","title":"Usage","text":"<pre><code>import mouette as M\nmesh = M.mesh.load(args.model)\ntutte = M.parametrization.TutteEmbedding(mesh, [boundary_mode], use_cotan=True, verbose=True)\ntutte.run()\nM.mesh.save(mesh, \"tutte_model.obj\")\nM.mesh.save(tutte.flat_mesh, \"tutte_flat.obj\")\n</code></pre>"},{"location":"algorithms/parametrization/Tutte/#tutteembedding","title":"TutteEmbedding","text":"<p>               Bases: <code>BaseParametrization</code></p> <p>Tutte's embedding parametrization method for a disk inside a fixed boundary. The parametrization is locally injective (Floater, 1997) provided the boundary is convex.</p> References <ul> <li> <p>[1] How to draw a graph, Tutte W.T., 1963</p> </li> <li> <p>[2] Parametrization and smooth approximation of surface triangulations, Floater M.S., 1997</p> </li> </ul> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/parametrization/tutte.py</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh to embed. Should be a surface with disk topology.</p> required <code>boundary_mode</code> <code>str</code> <p>Shape of the boundary. Possible choices are [\"square\", \"circle\", \"xy]. Defaults to \"circle\".</p> <code>'circle'</code> <code>use_cotan</code> <code>bool</code> <p>If True, uses cotangents as weights in the Laplacian matrix [2]. Otherwise, use Tutte's original barycentric embedding [1]. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>save_on_corners</code> <code>bool</code> <p>if True, the resulting uv-coordinates will be stored in an attribute on face corners. Otherwise, they are stored in an attribute on vertices. Defaults to True</p> <code>custom_boundary</code> <code>(ndarray, optionnal)</code> <p>a Nx2 array containing custom coordinates for the boundary vertices (N being the number of boundary vertices). </p> <p>Attributes:</p> Name Type Description <code>uvs</code> <code>Attribute</code> <p>an attribute containing the uv-coordinates of the parametrization</p> <code>save_on_corners</code> <code>bool</code> <p>whether the coordinates are saved as a vertex attribute or a face_corner attribute</p> <p>Raises:</p> Type Description <code>InvalidArgumentValueError</code> <p>if 'boundary_mode' is not a valid mode.</p>"},{"location":"algorithms/parametrization/Tutte/#mouette.processing.parametrization.tutte.TutteEmbedding.flat_mesh","title":"<code>flat_mesh</code>  <code>property</code>","text":"<p>A flat representation of the mesh where uv-coordinates are copied to xy.</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the flat mesh</p>"},{"location":"algorithms/parametrization/Tutte/#mouette.processing.parametrization.tutte.TutteEmbedding.run","title":"<code>run()</code>","text":"<p>Computes the parametrization. Result is stored in the <code>uvs</code> attribute</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the mesh is not a topological disk</p>"},{"location":"algorithms/parametrization/bff/","title":"Boundary First Flattening","text":""},{"location":"algorithms/parametrization/bff/#example","title":"Example","text":"<pre><code>import mouette as M\n\nmesh = M.mesh.load(\"path/to/mesh\")\nbff = M.parametrization.BoundaryFirstFlattening(mesh, bnd_scale_fctr=scale, verbose=True)\nmesh = bff.run() # /!\\ mesh is not modified in place\n</code></pre>"},{"location":"algorithms/parametrization/bff/#mouette.processing.parametrization.bff.BoundaryFirstFlattening","title":"<code>BoundaryFirstFlattening(mesh, bnd_scale_fctr=None, bnd_curvature=None, verbose=False, **kwargs)</code>","text":"<p>               Bases: <code>BaseParametrization</code></p> <p>Boundary First Flattening: A conformal flattening algorithm with control over the boundary  conditions, either in terms of scale factor or curvature</p> References <ul> <li>[1] Boundary First Flattening, Rohan Sawhney and Keenan Crane, ACM ToG, 2017</li> </ul> Warning <p>This algorithm reorders the vertices so that boundary vertices are labeled [0, N-1] in order. Therefore, the uvs coordinates are not computed on the original mesh but on a reordered copy. Access the final result with <code>self.mesh</code></p> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/parametrization/bff.py</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input surface. Should be a triangulation of a topological disk.</p> required <code>bnd_scale_fctr</code> <code>Attribute</code> <p>Scale factor on the boundary. Ignores values for interior vertices. Defaults to None. If provided, will automatically compute boundary curvature and ignore the <code>bnd_curvature</code>a argument.</p> <code>None</code> <code>bnd_curvature</code> <code>Attribute</code> <p>Geodesic curvature on the boundary. Ignores values for interior vertices. Defaults to None. If provided (and no <code>bnd_scale_fctr</code> is provided), will automatically compute boundary scale factors.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>save_on_corners</code> <code>bool</code> <p>if True, stores the results on face corners instead of vertices. Defaults to True</p> <code>use_cotan</code> <code>bool</code> <p>if True, uses the cotan Laplacian instead of the connectivity Laplacian. Defaults to True.</p> <code>hilbert_transform</code> <code>bool</code> <p>if True, extends the boundary values with the Hilbert transform </p> <p>Attributes:</p> Name Type Description <code>uvs</code> <code>Attribute</code> <p>an attribute containing the uv-coordinates of the parametrization</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the mesh is not the triangulation of a topological disk</p> Note <p>If neither of <code>bnd_scale_fctr</code> and <code>bnd_curvature</code> are provided, the algorithm will run in default mode with scale factors = 0 on the boundary. Otherwise, provided scale factors have priority over provided curvatures.</p>"},{"location":"algorithms/parametrization/bff/#mouette.processing.parametrization.bff.BoundaryFirstFlattening.flat_mesh","title":"<code>flat_mesh</code>  <code>property</code>","text":"<p>A flat representation of the mesh where uv-coordinates are copied to xy.</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the flat mesh</p>"},{"location":"algorithms/parametrization/bff/#mouette.processing.parametrization.bff.BoundaryFirstFlattening.run","title":"<code>run()</code>","text":"<p>Run the algorithm</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the mesh is not a triangulation of a topological disk</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a copy of the original mesh with reordered vertices and computed uv-coordinates</p>"},{"location":"algorithms/parametrization/cone_param/","title":"Cone Parametrization","text":"<p>Cone parametrization methods are a way to compute the parametrization of any surface with any topology. To understand the intuition that motivates them, one can think of a parametrization firstly as a process that displaces the curvature of a surface from its original distribution to zero everywhere except on the boundary. In the case of conformal maps, this idea is expressed by the Yamabe equation, that links the conformal parametrization, described by a scale factor \\(u\\), to the original and target Gaussian curvatures \\(K\\) and \\(\\hat{K}\\) by:</p> \\[Lu = K - \\hat{K}\\] <p>This curvature displacement is the source of the parametrization's distortion and needs to be minimal in some sense. In an effort to reduce distortion, one can try to find a suitable target curvature distribution \\(\\hat{K}\\) such that, for instance, the amplitude of \\(u\\) is minimized. This introduces specific vertices called cones (also called singularities) with non-zero angle defect in the parametrization. Cone parametrization therefore aim at finding a sparse set of cones that concentrate the whole curvature of the considered surface. From such a distribution, it is possible to retrieve \\(uv\\)-coordinates and an embedding in the plane by forcing these cones to lay on the boundary of the parametric domain. More precisely, given a set of cone vertices \\(S \\subset V\\), the following general algorithm can be applied:</p> <ul> <li>Perform cuts on edges in order to link every cone vertex (see the <code>SingularityCutter</code> class);</li> <li>Eventually perform additional cuts along non-contractible cycles in order to retrieve a disk topology;</li> <li>Apply any parametrization algorithm to the cut mesh.</li> </ul> <p> </p> Max Planck's bust model, mapped to the plane using a conformal cone parametrization. Four cones of defect pi/2 (red points) are placed on the model to reduce distortion"},{"location":"algorithms/parametrization/cone_param/#conformalconeparametrization","title":"ConformalConeParametrization","text":"<p>               Bases: <code>BaseParametrization</code></p> <p>Given a user-defined cone distribution on the surface, this algorithm cuts an input surface mesh into  a disk topology and parametrize it using conformal mapping</p> References <ul> <li> <p>[1] Conformal equivalence of triangle meshes, Springborn B., Schr\u00f6der P. and Pinkall U., ACM Transaction on Graphics, 2008</p> </li> <li> <p>[2] Boundary first flattening, Sawhney R. and Crane K., ACM Transaction on Graphics, 2018</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>Input mesh</p> required <code>cones</code> <code>Attribute</code> <p>float Attribute on vertices. Gives the target angle defects of vertices</p> required <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>use_cotan</code> <code>bool</code> <p>If True, uses cotangents in the laplacian matrix. Defaults to True. </p> <code>debug (bool, optional) </code> <p>debug mode. Generates additional output. Defaults to False.</p>"},{"location":"algorithms/parametrization/cone_param/#mouette.processing.parametrization.cone_param.ConformalConeParametrization.cut_graph","title":"<code>cut_graph</code>  <code>property</code>","text":"<p>The seams returned as a polyline</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>seams</p>"},{"location":"algorithms/parametrization/cone_param/#mouette.processing.parametrization.cone_param.ConformalConeParametrization.cut_mesh","title":"<code>cut_mesh</code>  <code>property</code>","text":"<p>The mesh where seams have been disconnected and are now boundary edges</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the mesh where seams have been disconnected</p>"},{"location":"algorithms/parametrization/cone_param/#mouette.processing.parametrization.cone_param.ConformalConeParametrization.flat_mesh","title":"<code>flat_mesh</code>  <code>property</code>","text":"<p>A flat representation of the mesh where uv-coordinates are copied to xy.</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the flat mesh</p>"},{"location":"algorithms/parametrization/cone_param/#mouette.processing.parametrization.cone_param.ConformalConeParametrization.frame_field","title":"<code>frame_field</code>  <code>property</code>","text":"<p>Local frames of reference rendered as a polyline</p>"},{"location":"algorithms/parametrization/cone_param/#mouette.processing.parametrization.cone_param.ConformalConeParametrization.run","title":"<code>run()</code>","text":"<p>Computes the parametrization</p>"},{"location":"algorithms/parametrization/cotan_embedding/","title":"Cotan Embedding","text":"<p>Given a triangulation \\(M=(V,T)\\) of a disk-topology object and some initial \\(uv\\)-coordinates on the vertices of \\(M\\), this method optimizes the \\(uv\\)-coordinates under fixed boundary so that no triangle is inverted in the final \\(uv\\)-mapping.</p> <p> </p> Notations for triangle $T=(i,j,k)$ <p>The algorithms minimizes the energy \\(E_T\\) per triangle, defined as:</p> \\[E_T = D_T - A_T\\] <p>where:</p> \\[D_T = \\displaystyle \\begin{pmatrix} \\cot(\\alpha_i) &amp; \\cot(\\alpha_j) &amp; \\cot(\\alpha_k) \\end{pmatrix} .     \\begin{pmatrix}        (u_j - u_k)^2 + (v_j - v_k)^2 \\\\        (u_i - u_k)^2 + (v_i - v_k)^2 \\\\       (u_i - u_j)^2 + (v_i - v_j)^2            \\end{pmatrix}\\] \\[A_T = \\frac{1}{2} \\det \\begin{pmatrix} u_j-u_i &amp; u_k-u_i \\\\ v_j-v_i &amp; v_k-v_i \\end{pmatrix}\\] <p>The first term \\(D_T\\) of this expression is the dot product between the vector of cotangents and the vector of opposite squared lengths. If the cotangents correspond to the angles made by \\(uv\\)-coordinates, then this quantity is exactly the unsigned area of triangle \\(T\\). The other term is half the determinant of \\(uv\\)-coordinates of the triangle, that is to say the signed area \\(A_T\\) of triangle \\(T\\). The energy we consider per triangle is simply the difference between the two.</p> <p>This energy can be minimized in two ways:</p>"},{"location":"algorithms/parametrization/cotan_embedding/#the-direct-optimization","title":"The direct optimization","text":"<p>The first strategy to minimize the energy is to put everything inside a non-linear solver like L-BFGS. However, this optimization may result in cotangents that do not form valid triangles, hence we need to introduce the constraint: \\(\\cot(\\alpha_i)\\cot(\\alpha_j) + \\cot(\\alpha_j)\\cot(\\alpha_k) + \\cot(\\alpha_k)\\cot(\\alpha_i) = 1\\) for all triangles \\(T\\).</p> <p>Using Lagrange multipliers, we are able to reformulate the constrained problem as:</p> \\[\\min_{u,v} \\sum_{T=(i,j,k)} \\sqrt{2( \\ell_i \\ell_j + \\ell_j \\ell_k + \\ell_k \\ell_i) - \\ell_i^2 - \\ell_j^2 - \\ell_k^2} \\;-\\, A_T\\] <p>where \\(\\ell_i = (u_j - u_k)^2 + (v_j - v_k)^2\\) is the squared distance between \\(j\\) and \\(k\\) in parameter space. This means that the final energy only depends on the \\(uv\\)-coordinates.</p>"},{"location":"algorithms/parametrization/cotan_embedding/#the-iterative-approach","title":"The iterative approach","text":"<p>Alternatively, the energy can be minimized by iteratively solving linear systems involving a cotan-Laplacian, where the cotangent are updated at each step to match the cotangents given by the \\(uv\\)-coordinates:</p> \\[\\cot(\\alpha_k) = \\frac{ (u_i-u_k)(u_j-u_k) + (v_i-v_k)(v_j-v_k) }{(u_i-u_k)(v_j-v_k) - (u_j-u_k)(v_i-v_k)}.\\] <p>This approach is more stable and provides good results in more cases, but the final parametrizations are close to conformal and thus can exhibit high area distortions.</p>"},{"location":"algorithms/parametrization/cotan_embedding/#result","title":"Result","text":"Initial flattening of a butterfly model (with folds in red) Final result with L-BFGS approach Final result with iterative Tutte approach"},{"location":"algorithms/parametrization/cotan_embedding/#references","title":"References","text":"<ul> <li>[1] Embedding a triangular graph within a given boundary, Yin Xu, Renjie Chen, Craig Gotsman and Ligang Liu, Computer Aided Geometric Design (2011)</li> <li>[2] Global Parametrization Algorithms for Quadmeshing, Guillaume Coiffier, PhD Manuscript (Chapter 3)</li> </ul>"},{"location":"algorithms/parametrization/cotan_embedding/#usage","title":"Usage","text":"<p><pre><code>import mouette as M\n\nemb = M.parametrization.CotanEmbedding(mesh, uv_attributes, mode=\"bfgs\")()\n</code></pre> or, alternatively:</p> <pre><code>emb = M.parametrization.CotanEmbedding(mesh, uv_attributes, mode=\"bfgs\")\nemb.run()\n</code></pre>"},{"location":"algorithms/parametrization/cotan_embedding/#mouette.processing.parametrization.cotan_emb.CotanEmbedding","title":"<code>CotanEmbedding(mesh, uv_init, mode='bfgs', verbose=False, **kwargs)</code>","text":"<p>               Bases: <code>BaseParametrization</code></p> <p>Given a parametrization of a disk where boundary is fixed, we can optimize the difference between unsigned and signed areas of triangles to compute a parametrization that is foldover-free.</p> Warning <p>The input mesh should have the topology of a disk.</p> <p>UV coordinates are computed per vertex and not per corner. See <code>mouette.attributes.scatter_vertices_to_corners</code> for conversion.</p> References <p>[1] Embedding a triangular graph within a given boundary, Xu et al. (2011)</p> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/parametrization/cotan_embedding.py</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh.</p> required <code>uv_init</code> <code>ArrayAttribute</code> <p>array of initial uv-coordinates per vertices. np.array of shape (V,2) or mouette.ArrayAttribute object.</p> required <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <code>mode</code> <code>str</code> <p>optimization mode. Either \"bfgs\" or \"alternate\". Defaults to \"bfgs\".</p> <code>'bfgs'</code> <p>Other Parameters:</p> Name Type Description <code>tutte_if_convex</code> <code>bool</code> <p>if True and if the boundary of the shape is convex and mode==\"alternate\", will simply runs Tutte's embedding. Defaults to True</p> <code>solver_verbose</code> <code>bool</code> <p>solver verbose mode. Defaults to False.</p>"},{"location":"algorithms/parametrization/cotan_embedding/#mouette.processing.parametrization.cotan_emb.CotanEmbedding.flat_mesh","title":"<code>flat_mesh</code>  <code>property</code>","text":"<p>A flat representation of the mesh where uv-coordinates are copied to xy.</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the flat mesh</p>"},{"location":"algorithms/parametrization/cotan_embedding/#mouette.processing.parametrization.cotan_emb.CotanEmbedding.run","title":"<code>run()</code>","text":"<p>Runs the optimization</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Fails if the mesh is not a topological disk</p> <code>Exception</code> <p>Fails if the mesh is not triangular</p>"},{"location":"algorithms/parametrization/distortion/","title":"Measuring Distortion","text":"<p>Utilities classes to compute distortions of elements between \"real\" \\(xyz\\)-space and \"parametric\" \\(uv\\)-space.</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion","title":"<code>ParamDistortion(mesh, uv_attr='uv_coords', save_on_mesh=True, verbose=False)</code>","text":"<p>               Bases: <code>Worker</code></p> <p>Utility class to compute various distortion metrics for surface parametrization.</p> <p>Initializes the distortion utility class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh</p> required <code>uv_attr</code> <code>str</code> <p>the attribute name that stores the uv-coordinates on face corners. Defaults to \"uv_coords\".</p> <code>'uv_coords'</code> <code>save_on_mesh</code> <code>bool</code> <p>If True, distortion values will be stored as attributes on the mesh. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the attribute 'uv_attr' does not exists.</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion.conformal","title":"<code>conformal</code>  <code>property</code>","text":"<p>Conformal distortion, defined as \\(\\frac{||J||^2}{\\det(J)}\\)</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion.det","title":"<code>det</code>  <code>property</code>","text":"<p>Jacobian determinants of each element</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion.iso","title":"<code>iso</code>  <code>property</code>","text":"<p>Isometric distortion</p> <p>Defined as the distance from (\\(\\sigma_1\\), \\(\\sigma_2\\)) to (1,1) where \\(\\sigma_1\\) and \\(\\sigma_2\\) are the eigenvalues of J</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale distortion, defined as \\(\\frac12 (\\det(J) + 1/\\det(J))\\)</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion.shear","title":"<code>shear</code>  <code>property</code>","text":"<p>Shear distortion</p> <p>Defined as \\(c1 \\cdot c2\\) where \\(c1\\) and \\(c2\\) are the columns of J</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion.stretch","title":"<code>stretch</code>  <code>property</code>","text":"<p>Stretch distortion</p> <p>Defined as the ratio \\(\\frac{\\sigma_1}{\\sigma_2}\\) where \\(\\sigma_1\\) and \\(\\sigma_2\\) are the eigenvalues of J</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion.summary","title":"<code>summary</code>  <code>property</code>","text":"<p>Computes a summary dictionnary of all distortion values as an average over the mesh</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>a dictionnary with aggregated values over the mesh</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.ParamDistortion.run","title":"<code>run()</code>","text":"<p>Run the distortion computation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the mesh is not triangular.</p> <code>ZeroDivisionError</code> <p>if degenerated elements are present in the parametrization.</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.QuadQuality","title":"<code>QuadQuality(mesh, save_on_mesh=True, verbose=False)</code>","text":"<p>               Bases: <code>Worker</code></p> <p>Utility class to compute various quality metrics on quad meshes</p>"},{"location":"algorithms/parametrization/distortion/#mouette.processing.parametrization.distortion.QuadQuality.run","title":"<code>run()</code>","text":"<p>Runs the distortion computation</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the mesh is not a quadmesh</p>"},{"location":"algorithms/parametrization/ff_integration/","title":"Frame Field Integration","text":"<p>A frame field on a surface mesh can be thought as gradient vectors of some scalar functions. Retrieving a parametrization involves \"integrating\" this field to recover those scalar coordinates \\(u\\) and \\(v\\).</p> <p>The algorithm proceeds as follows:</p> <ul> <li> <p>Smooth a frame field on faces of a mesh</p> </li> <li> <p>Determine the singularities and cut along seams to recover a disk topology</p> </li> <li> <p>Brush the frame field: determine which branch of the cross will correspond to \\(u\\) and to \\(v\\) at each face</p> </li> <li> <p>Integrate the two vector fields: find the two functions \\(u\\) and \\(v\\) whose gradient match the two vector fields in the least-square sense.</p> </li> </ul> <p> </p> Left: Brushed frame field defined on the faces of a CAD model. Singularities are depicted in red (+pi/2) and blue (-pi/2). Right: seamless parametrization computed by integrating the frame field"},{"location":"algorithms/parametrization/ff_integration/#framefieldintegration","title":"FrameFieldIntegration","text":""},{"location":"algorithms/parametrization/ff_integration/#usage","title":"Usage","text":"<pre><code>ff = M.framefield.SurfaceFrameField(mesh, \"faces\") \n# /!\\ Integration is supported only for a frame field defined on faces\nff_param = M.parametrization.FrameFieldIntegration(ff, verbose=True)\nff_param.run()\nuvs = mesh.face_corners.get_attribute(\"uv_coords\")\n</code></pre> <p>               Bases: <code>BaseParametrization</code></p> <p>Integration of a smooth vector field into a seamless parametrization</p> References <ul> <li> <p>[1] Mixed-integer quadrangulation, Bommes D, Zimmer H. and Kobbelt L., ACM Transaction on Graphics, 2009</p> </li> <li> <p>[2] QuadCover - Surface Parameterization using Branched Coverings, K\u00e4lberer F., Nieser M. and Polthier K., Computer Graphics Forum, 2007</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>framefield</code> <code>FrameField</code> <p>the frame field object to integrate.</p> required <code>singularities</code> <code>Attribute</code> <p>float Attribute on vertices. Gives the target angle defects of vertices</p> required <code>use_cotan</code> <code>bool</code> <p>if True, uses cotangents as weights in the laplacian matrix. Defaults to True. </p> required <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>debug (bool, optional) </code> <p>debug mode. Generates additionnal output. Defaults to False.</p> Note <p>It is not necessary to provide the input mesh, as it is accessed via the <code>framefield</code> argument</p> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/parametrization/ff_integrate.py</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>the frame field should be defined on faces and be of order 4</p>"},{"location":"algorithms/parametrization/ff_integration/#mouette.processing.parametrization.ff_integration.FrameFieldIntegration.cut_graph","title":"<code>cut_graph</code>  <code>property</code>","text":"<p>Seam edges as a PolyLine</p>"},{"location":"algorithms/parametrization/ff_integration/#mouette.processing.parametrization.ff_integration.FrameFieldIntegration.cut_mesh","title":"<code>cut_mesh</code>  <code>property</code>","text":"<p>Disk-topology mesh where cuts have been performed on seams</p>"},{"location":"algorithms/parametrization/ff_integration/#mouette.processing.parametrization.ff_integration.FrameFieldIntegration.flat_mesh","title":"<code>flat_mesh</code>  <code>property</code>","text":"<p>A flat representation of the mesh where uv-coordinates are copied to xy.</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the flat mesh</p>"},{"location":"algorithms/parametrization/ff_integration/#mouette.processing.parametrization.ff_integration.FrameFieldIntegration.seam_graph","title":"<code>seam_graph</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>Polyline of seam edges</p>"},{"location":"algorithms/parametrization/ff_integration/#mouette.processing.parametrization.ff_integration.FrameFieldIntegration.export_frame_field_as_mesh","title":"<code>export_frame_field_as_mesh()</code>","text":"<p>Exports the frame field as a PolyLine for visualization</p>"},{"location":"algorithms/parametrization/ff_integration/#mouette.processing.parametrization.ff_integration.FrameFieldIntegration.run","title":"<code>run()</code>","text":"<p>Computes the integration</p>"},{"location":"algorithms/parametrization/lscm/","title":"Least-Square Conformal Maps","text":"<p>https://en.wikipedia.org/wiki/Least_squares_conformal_map</p>"},{"location":"algorithms/parametrization/lscm/#usage","title":"Usage","text":"<pre><code>import mouette as M\n\nmesh = M.mesh.load(\"path/to/mesh\")\nlscm = M.parametrization.LSCM(mesh, [options])\nlscm.run()\n</code></pre>"},{"location":"algorithms/parametrization/lscm/#mouette.processing.parametrization.lscm.LSCM","title":"<code>LSCM(mesh, verbose=False, **kwargs)</code>","text":"<p>               Bases: <code>BaseParametrization</code></p> <p>Least-Square Conformal Map algorithm for computing a parametrization of a mesh. /!\\ The mesh should have the topology of a disk. Computed UVs are stored in the self.uvs container</p> References <ul> <li>[1] Least Squares Conformal Maps for Automatic Texture Atlas Generation, Levy et al. (2002)</li> <li>[2] Spectral Conformal Parameterization, Mullen et al. (2008)</li> <li>[3] Intrinsic Parameterizations of Surface Meshes, Desbrun et al. (2002)</li> </ul> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/parametrization/lscm.py</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh. Should be a surface with disk topology.</p> required <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>eigen</code> <code>bool</code> <p>whether to solve a linear system with two fixed points or use an eigen solver. Defaults to True</p> <code>save_on_corners</code> <code>bool</code> <p>whether to store the results on face corners or vertices. Defaults to True</p> <code>solver_verbose</code> <code>bool</code> <p>verbose level. Defaults to False.</p> <p>Attributes:</p> Name Type Description <code>uvs</code> <code>Attribute</code> <p>an attribute containing the uv-coordinates of the parametrization</p> <code>save_on_corners</code> <code>bool</code> <p>whether the coordinates are saved as a vertex attribute or a face_corner attribute</p> <code>residual</code> <code>float</code> <p>the least-square residual</p>"},{"location":"algorithms/parametrization/lscm/#mouette.processing.parametrization.lscm.LSCM.flat_mesh","title":"<code>flat_mesh</code>  <code>property</code>","text":"<p>A flat representation of the mesh where uv-coordinates are copied to xy.</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the flat mesh</p>"},{"location":"algorithms/parametrization/lscm/#mouette.processing.parametrization.lscm.LSCM.run","title":"<code>run()</code>","text":"<p>Calls the solver on the LSCM system.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the mesh is not a topological disk</p>"},{"location":"algorithms/parametrization/orbifold_tutte/","title":"Orbifold Tutte Embeddings","text":"<p>Implementation of the Orbifold Tutte Embedding technique from Noam Aigerman and Yaron Lipman.</p> <p>This method embeds a sphere-topology mesh into an Euclidean orbifold, that is a chart that paves the plane up to some rotation. In practice, it defines cuts between a set of prescribed cones on the surface which become virtual seams. The parametrization's distortion only depends on the position of the cones.</p> <p>They are four ways to perform such an embedding: 1) Square orbifold : 3 cones of \\(\\pi/2\\), \\(\\pi\\) and \\(\\pi/2\\) 2) Diamond orbifold : 3 cones \\(2\\pi/3\\), \\(2\\pi/3\\) and \\(2\\pi/3\\) 3) Triangle orbifold : 3 cones of \\(\\pi\\), \\(2\\pi/3\\) and \\(\\pi/3\\) 4) Parallelogram orbifold : 4 cones of \\(\\pi\\), \\(\\pi\\), \\(\\pi\\) and \\(\\pi\\) </p> <p> </p> Four types of orbifolds (respectively square, diamond, triangle and parallelogram). Figure from the paper. <p>Note</p> <p>Only the \"square\" and the \"parallelogram\" are currently implemented in <code>mouette</code>.</p>"},{"location":"algorithms/parametrization/orbifold_tutte/#usage","title":"Usage","text":"<pre><code>import mouette as M\nmesh = M.mesh.load(args.model)\norbifold_type = \"parallelogram\" # 4 cones, or \"square\" for 3 cones\norbTutte = M.parametrization.OrbifoldTutteEmbedding(mesh, orbifold_type, cones)\norbTutte.run()\n</code></pre>"},{"location":"algorithms/parametrization/orbifold_tutte/#mouette.processing.parametrization.orbifold_tutte.OrbifoldTutteEmbedding","title":"<code>OrbifoldTutteEmbedding(mesh, orbifold_type, cones, use_cotan=True, verbose=False, **kwargs)</code>","text":"<p>               Bases: <code>BaseParametrization</code></p> <p>Orbifold Tutte's embedding generalizes Tutte's embedding to spherical topologies. Using periodic conditions on a virtually defined boundary, it creates a parametrization that is a tiling of the plane, leading to a seamless parametrization of meshes with sphere topologies</p> References <p>[1] Orbifold Tutte Embeddings, Noam Aigerman and Yaron Lipman, ACM Transaction on Graphics, 2015</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh to embed. Should be a surface with disk topology.</p> required <code>orbifold_type</code> <code>str</code> <p>which orbifold to project to. Choices are [\"square\", \"diamond\", \"triangle\", \"parallelogram\"].</p> required <code>cones</code> <code>iterable</code> <p>Cone points that define the virtual boundary (three or four points, depending on the orbifold type). Need to be valid vertex indices. If not specified, will be generated automatically. Defaults to None.</p> required <code>use_cotan</code> <code>bool</code> <p>whether to use Tutte's original barycentric embedding [1], or use cotangents as weights in the laplacian matrix ([2]). Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to True.</p> <code>False</code>"},{"location":"algorithms/parametrization/orbifold_tutte/#mouette.processing.parametrization.orbifold_tutte.OrbifoldTutteEmbedding.cones_as_pointcloud","title":"<code>cones_as_pointcloud</code>  <code>property</code>","text":"<p>Returns the cone distribution as a point cloud</p>"},{"location":"algorithms/parametrization/orbifold_tutte/#mouette.processing.parametrization.orbifold_tutte.OrbifoldTutteEmbedding.flat_mesh","title":"<code>flat_mesh</code>  <code>property</code>","text":"<p>A flat representation of the mesh where uv-coordinates are copied to xy.</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the flat mesh</p>"},{"location":"algorithms/parametrization/surface_cutting/","title":"Surface Cutting","text":""},{"location":"algorithms/parametrization/surface_cutting/#surfacemeshcutter","title":"SurfaceMeshCutter","text":"<p>Given a surface mesh and a set of edges, this utility class will perform cuts along the prescribed edges, disconnecting their two adjacent faces.</p>"},{"location":"algorithms/parametrization/surface_cutting/#usage","title":"Usage","text":"<pre><code>cutter = SurfaceMeshCutter(mesh)\ncutter.cut(edge_list)\n</code></pre> <p>or</p> <pre><code>cutter = SurfaceMeshCutter(mesh)(edge_list) # directly calls cut\n</code></pre> <p>               Bases: <code>Worker</code></p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>cut_edges</code> <code>set</code> <p>indices of edges that were cut</p> <code>cut_mesh</code> <code>SurfaceMesh</code> <p>a copy of the mesh where specified edges have been cut</p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SurfaceMeshCutter.cut_graph","title":"<code>cut_graph</code>  <code>property</code>","text":"<p>The graph formed by all cut edges as a Polyline object</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the cut graph</p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SurfaceMeshCutter.cut","title":"<code>cut(edges_to_cut)</code>","text":"<p>Cut the mesh. Alias for <code>SurfaceMeshCutter.run</code></p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SurfaceMeshCutter.duplicated_vertices","title":"<code>duplicated_vertices(v)</code>","text":"<p>Given the index v of a vertex in the input mesh, returns the set of all copies of v in the cut mesh.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>int</code> <p>index of a vertex in the input mesh</p> required <p>Returns:</p> Type Description <code>set</code> <p>set[int]: all vertex indices corresponding to copies of v in the cut mesh</p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SurfaceMeshCutter.ref_vertex","title":"<code>ref_vertex(v_cut)</code>","text":"<p>Given the index <code>v_cut</code> of a vertex in the cut mesh, returns the index of the corresponding vertex in the original mesh.</p> <p>Parameters:</p> Name Type Description Default <code>v_cut</code> <code>int</code> <p>index of a vertex in the cut mesh. If the index is invalid, returns None</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>index of the reference vertex in the original mesh</p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SurfaceMeshCutter.run","title":"<code>run(edges_to_cut)</code>","text":"<p>Cut the mesh. Fills the attributes and builds <code>cut_mesh</code>, which is a copy of the input mesh with corresponding edges disconnected</p> <p>Parameters:</p> Name Type Description Default <code>edges_to_cut</code> <code>Iterable</code> <p>containers of all the indices of edges to be cut</p> required"},{"location":"algorithms/parametrization/surface_cutting/#singularitycutter","title":"SingularityCutter","text":"<p>Given some indices in the mesh, performs cuts on the same so that: 1) every prescribed vertex becomes a boundary vertex 2) the final mesh has disk topology.  </p> <p>This utility class allows to define the discontinuities of a seamless global parametrization and go back and forth between the original mesh and the cut mesh.</p> <p>Three strategies for computing the cuts are available:     - (A) Simple strategy: no heuristics. Computes a valid seam graph with no geometrical consideration.     - (B) Shortest path strategy: tries to minimize the total length of seams by encouraging cuts to follow shortest paths between singularities.     - (C) Follow features strategy: minimize the number of seam edges that do not belong to the feature graph (i.e. sharp edges) of the model. Requires to first run a <code>FeatureEdgeDetector</code> on the mesh.  </p> <p> </p> Illustration of the three cutting strategies"},{"location":"algorithms/parametrization/surface_cutting/#usage_1","title":"Usage","text":"<pre><code>cutter = SingularityCutter(mesh, indices, strategy=\"shortest\")\ncutter.run()\n</code></pre> <p>               Bases: <code>SurfaceMeshCutter</code></p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <code>singularities</code> <code>list</code> <p>indices of the singular vertices</p> required <code>strategy</code> <code>str</code> <p>which strategy to use. Choices are [\"auto\", \"simple\", \"short\", \"feat\", \"limited\"]</p> <code>'auto'</code> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to False.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>features</code> <code>FeatureEdgeDetector</code> <p>feature edge data structure. If provided, the cuts will follow the feature as much as possible. Defaults to None.</p> <code>debug</code> <code>bool</code> <p>debug mode. Computes additionnal outputs as mesh attributes. Defaults to False</p> <p>Attributes:</p> Name Type Description <code>cut_edges</code> <code>set</code> <p>indices of edges that were cut</p> <code>cut_mesh</code> <code>SurfaceMesh</code> <p>a copy of the mesh where specified edges have been cut</p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SingularityCutter.cut_graph","title":"<code>cut_graph</code>  <code>property</code>","text":"<p>The graph formed by all cut edges as a Polyline object</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the cut graph</p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SingularityCutter.duplicated_vertices","title":"<code>duplicated_vertices(v)</code>","text":"<p>Given the index v of a vertex in the input mesh, returns the set of all copies of v in the cut mesh.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>int</code> <p>index of a vertex in the input mesh</p> required <p>Returns:</p> Type Description <code>set</code> <p>set[int]: all vertex indices corresponding to copies of v in the cut mesh</p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SingularityCutter.ref_vertex","title":"<code>ref_vertex(v_cut)</code>","text":"<p>Given the index <code>v_cut</code> of a vertex in the cut mesh, returns the index of the corresponding vertex in the original mesh.</p> <p>Parameters:</p> Name Type Description Default <code>v_cut</code> <code>int</code> <p>index of a vertex in the cut mesh. If the index is invalid, returns None</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>index of the reference vertex in the original mesh</p>"},{"location":"algorithms/parametrization/surface_cutting/#mouette.processing.cutting.SingularityCutter.run","title":"<code>run()</code>","text":"<p>Runs the cutting process</p>"},{"location":"algorithms/parametrization/winslow/","title":"Foldover-free maps","text":"<p>Implementation of the Foldover-free maps in 50 lines of code paper by Garanzha et al.</p>"},{"location":"algorithms/parametrization/winslow/#usage","title":"Usage","text":"<pre><code>import mouette as M\nuntangler = M.parametrization.WinslowInjectiveEmbedding(mesh, uv_init, lmbd=1.)\nuntangler.run()\n</code></pre> <p>See this script for a full example.</p>"},{"location":"algorithms/parametrization/winslow/#method","title":"Method","text":"<p>Given a triangulation \\(M=(V,T)\\) of a disk-topology object and some initial \\(uv\\)-coordinates on the vertices of \\(M\\), this method optimizes the \\(uv\\)-coordinates under fixed boundary so that no triangle is inverted in the final \\(uv\\)-mapping. This is done through the optimization of an energy function that acts on jacobian matrices \\(J \\in \\mathbb{R}^2\\) of each triangle elements:</p> \\[ \\min_J f_\\varepsilon(J) + g_\\varepsilon(J)\\] <p>where:</p> \\[f_\\varepsilon(J) = \\frac{\\text{tr}(J^TJ)}{\\chi(\\det J, \\varepsilon)} \\quad \\quad  g_\\varepsilon(J) = \\frac{\\det{J}^2 + 1}{\\chi(\\det J,\\varepsilon)}\\] <p>and \\(\\chi\\) is a regularization function:</p> \\[\\chi(D, \\varepsilon) = \\frac{D + \\sqrt{\\varepsilon^2 + D^2}}{2}.\\] <p>\\(\\varepsilon\\) is chosen during optimization as a decreasing sequence.</p>"},{"location":"algorithms/parametrization/winslow/#mouette.processing.parametrization.winslow.WinslowInjectiveEmbedding","title":"<code>WinslowInjectiveEmbedding(mesh, uv_init, lmbd=1.0, n_iter_max=10000, stop_if_positive=False, verbose=True, **kwargs)</code>","text":"<p>               Bases: <code>BaseParametrization</code></p> <p>Foldover-free map to the plane: computes an injective embedding in the plane starting from the provided \\(uv\\)-coordinates by minimizing the regularized Winslow functionnal of Garanzha et al. [1]. This class is essentially a wrapper around the <code>untangle</code> function.</p> Warning <p>The input mesh should have the topology of a disk.</p> <p>UV coordinates are computed per vertex and not per corner. See <code>mouette.attributes.scatter_vertices_to_corners</code> for conversion.</p> References <p>[1] Foldover-free maps in 50 lines of code, Garanzha et al., ACM ToG 2021</p> Example <p>See https://github.com/GCoiffier/mouette/blob/main/examples/winslow_untangle.py</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the supporting mesh. Should be a surface with disk topology.</p> required <code>uv_init</code> <code>ArrayAttribute</code> <p>array of initial uv-coordinates per vertices. np.array of shape (V,2) or mouette.ArrayAttribute object.</p> required <code>lmbd</code> <code>float</code> <p>weighting term between the two energies. Higher lambda means more focus on area preservation instead of angle preservation. Defaults to 1.</p> <code>1.0</code> <code>n_iter_max</code> <code>int</code> <p>maximal number of BFGS iterations. Defaults to 10_000.</p> <code>10000</code> <code>stop_if_positive</code> <code>bool</code> <p>whether to stop the optimization as soon as all determinants are positive. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>verbose mode. Defaults to True.</p> <code>True</code> <p>Other Parameters:</p> Name Type Description <code>ref_jacs</code> <code>ndarray</code> <p>array of shape (F,2,2) that contains, for each face, the 2x2 reference Jacobian of the face. If not provided, reference Jacobians are taken as the identity matrix. Defaults to None.</p> <code>areas</code> <code>Attribute</code> <p>face areas, or weight per face in winslow energy. If not provided, weights are taken as 1 for each face. Defaults to None.</p> <code>solver_verbose</code> <code>bool</code> <p>Verbose tag for the L-BFGS solver. Defaults to False.</p> <p>Attributes:</p> Name Type Description <code>uvs</code> <code>Attribute</code> <p>an attribute containing the uv-coordinates of the parametrization</p>"},{"location":"algorithms/parametrization/winslow/#mouette.processing.parametrization.winslow.WinslowInjectiveEmbedding.flat_mesh","title":"<code>flat_mesh</code>  <code>property</code>","text":"<p>A flat representation of the mesh where uv-coordinates are copied to xy.</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the flat mesh</p>"},{"location":"algorithms/parametrization/winslow/#mouette.processing.parametrization.winslow.WinslowInjectiveEmbedding.run","title":"<code>run()</code>","text":"<p>Calls the solver.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the mesh is not a triangulation of a topological disk</p>"},{"location":"algorithms/parametrization/winslow/#mouette.processing.parametrization.winslow.untangle","title":"<code>untangle(points, locked, triangles, ref_jacs, verbose=False, **kwargs)</code>","text":"<p>Minimizes the regularized Winslow functional to untangle a 2D triangulation.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray[float]</code> <p>Initial position of points in 2D. Should be of shape (V,2) or (2V,)</p> required <code>locked</code> <code>ndarray[bool]</code> <p>Which points have a fixed position. Should be of shape (V,)</p> required <code>triangles</code> <code>ndarray[int]</code> <p>Indices of triangles. Should be of shape (T,3)</p> required <code>ref_jacs</code> <code>ndarray[float]</code> <p>Perfect element to consider for Jacobian computation for each triangle. Should be of shape (T,2,2).</p> required <code>verbose</code> <code>(bool, optional)</code> <p>Verbose mode. Defaults to False.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>areas</code> <code>ndarray[float]</code> <p>Areas of triangles in original mesh. Used as a weighting term in the energy's summation. Should be of shape (T,). Defaults to np.ones(T).</p> <code>weight_angles</code> <code>float</code> <p>weight coefficient for the angle conservation term (f). Defaults to 1.</p> <code>weight_areas</code> <code>float</code> <p>weight coefficient for the area conservation term (g). Defaults to 1.</p> <code>iter_max</code> <code>int</code> <p>Maximum number of iterations in the L-BFGS solver. Defaults to 10000.</p> <code>n_eps_update</code> <code>int</code> <p>number of updates of the regularization's epsilon. Defaults to 10.</p> <code>stop_if_positive</code> <code>bool</code> <p>enable early stopping as soon as all dets are positive. Defaults to False.</p> <code>num_threads</code> <code>int</code> <p>number of parallel threads for energy computation. Defaults to 2.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray[float]: final positions of points in 2D, in shape (2V,)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the provided points are not of shape (V,2) or (2V,) </p> References <p>[1] Foldover-free maps in 50 lines of code, Garanzha et al., ACM ToG 2021</p>"},{"location":"attributes/global/","title":"Global attributes","text":""},{"location":"attributes/global/#mouette.attributes.glob.barycenter","title":"<code>barycenter(mesh)</code>","text":"<p>Barycenter of the vertices of the mesh</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>input mesh</p> required <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>coordinates of the barycenter</p>"},{"location":"attributes/global/#mouette.attributes.glob.euler_characteristic","title":"<code>euler_characteristic(mesh)</code>","text":"<p>Computes the Euler characteristic of a surface mesh, given as V-E+F</p> <p>See https://en.wikipedia.org/wiki/Euler_characteristic</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh</p> required <p>Returns:</p> Type Description <code>int</code> <p>the Euler characteristic</p>"},{"location":"attributes/global/#mouette.attributes.glob.mean_cell_volume","title":"<code>mean_cell_volume(mesh, n=None)</code>","text":"<p>Estimation of mean cell volume</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VolumeMesh</code> <p>input mesh</p> required <code>n</code> <code>int</code> <p>Early stopping for number of cells to consider in mean computation.  If set to None, considers all the cells. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the computed mean cell volume</p>"},{"location":"attributes/global/#mouette.attributes.glob.mean_edge_length","title":"<code>mean_edge_length(mesh, n=None)</code>","text":"<p>Estimation of mean edge length</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>input mesh</p> required <code>n</code> <code>int</code> <p>Early stopping for number of edges to consider in mean computation.  If set to None, considers all the edges. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the computed mean edge length</p>"},{"location":"attributes/global/#mouette.attributes.glob.mean_face_area","title":"<code>mean_face_area(mesh, n=None)</code>","text":"<p>Estimation of mean face area</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>input mesh</p> required <code>n</code> <code>int</code> <p>Early stopping for number of faces to consider in mean computation.  If set to None, considers all the faces. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the computed mean face area</p>"},{"location":"attributes/global/#mouette.attributes.glob.total_area","title":"<code>total_area(mesh)</code>","text":"<p>Sum of face areas</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>input mesh</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the computed mean face area</p>"},{"location":"attributes/interpolation/","title":"Attribute Interpolation","text":""},{"location":"attributes/interpolation/#mouette.attributes.interpolate.average_corners_to_faces","title":"<code>average_corners_to_faces(mesh, cattr, fattr, weight='uniform')</code>","text":"<p>Given an attribute on corners, computes a face attribute that is the average per face</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh</p> required <code>cattr</code> <code>Attribute</code> <p>input corner attribute</p> required <code>fattr</code> <code>Attribute</code> <p>output face attribute</p> required <code>weight</code> <code>str</code> <p>the way attributes are weighted in the sum. three possibilities: - uniform: every corner will have weight 1/n - angle: corners contribute to a fae depending on the interior angle - sum: do not consider weights and just add the value at corners</p> <code>'uniform'</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>modified fattr</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if 'weight' is not in {'uniform', 'angle', 'sum'}</p>"},{"location":"attributes/interpolation/#mouette.attributes.interpolate.average_corners_to_vertices","title":"<code>average_corners_to_vertices(mesh, cattr, vattr, weight='uniform')</code>","text":"<p>Given an attribute on corners, computes a vertex attribute that is the average per vertex</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh</p> required <code>cattr</code> <code>Attribute</code> <p>input corner attribute</p> required <code>vattr</code> <code>Attribute</code> <p>output vertex attribute</p> required <code>weight</code> <code>str</code> <p>the way attributes are weighted in the sum. three possibilities: - uniform: every corner will have weight 1/n - angle: corners contribute to a vertex depending on the interior angle at this vertex - sum: do not consider weights and just add the value at corners</p> <code>'uniform'</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>modified vattr</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if 'weight' is not in {'uniform', 'angle', 'sum'}</p>"},{"location":"attributes/interpolation/#mouette.attributes.interpolate.interpolate_faces_to_vertices","title":"<code>interpolate_faces_to_vertices(mesh, fattr, vattr, weight='uniform')</code>","text":"<p>Given an attribute on faces, interpolates its value onto vertices</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh</p> required <code>fattr</code> <code>Attribute</code> <p>input face attribute</p> required <code>vattr</code> <code>Attribute</code> <p>output face attribute</p> required <code>weight</code> <code>str</code> <p>the way attributes are weighted in the sum. four possibilities :</p> <ul> <li> <p>uniform: every face will have weight 1</p> </li> <li> <p>area: face have a weight proportionnal to their area</p> </li> <li> <p>angle: face contribute to a vertex depending on the interior angle at this vertex</p> </li> <li> <p>sum : like uniform but does not divide</p> </li> </ul> <code>'uniform'</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>modified vattr</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if 'weight' is not in {'uniform', 'area', 'angle', 'sum'}</p>"},{"location":"attributes/interpolation/#mouette.attributes.interpolate.interpolate_vertices_to_faces","title":"<code>interpolate_vertices_to_faces(mesh, vattr, fattr)</code>","text":"<p>Given an attribute on vertices, interpolates its value onto faces</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[SurfaceMesh, VolumeMesh]</code> <p>the input mesh</p> required <code>vattr</code> <code>Attribute</code> <p>input vertex attribute </p> required <code>fattr</code> <code>Attribute</code> <p>output face attribute</p> required <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>fattr</p>"},{"location":"attributes/interpolation/#mouette.attributes.interpolate.scatter_faces_to_corners","title":"<code>scatter_faces_to_corners(mesh, fattr, cattr)</code>","text":"<p>Given an attribute on faces, distributes its values onto corresponding corners.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh</p> required <code>fattr</code> <code>Attribute</code> <p>input face attribute</p> required <code>cattr</code> <code>Attribute</code> <p>output face corner attribute</p> required <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>cattr</p>"},{"location":"attributes/interpolation/#mouette.attributes.interpolate.scatter_vertices_to_corners","title":"<code>scatter_vertices_to_corners(mesh, vattr, cattr)</code>","text":"<p>Given an attribute on vertices, distributes its values onto corresponding corners.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh</p> required <code>vattr</code> <code>Attribute</code> <p>input vertex attribute</p> required <code>cattr</code> <code>Attribute</code> <p>output face corner attribute</p> required <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>cattr</p>"},{"location":"attributes/per_elements/","title":"Per element attributes","text":""},{"location":"attributes/per_elements/#vertices","title":"Vertices","text":""},{"location":"attributes/per_elements/#mouette.attributes.attr_vertices.angle_defects","title":"<code>angle_defects(mesh, zero_border=False, name='angleDefect', persistent=True, dense=True)</code>","text":"<p>Computes the angle defect at each vertex, defined as 2*pi minus the sum of angles around the vertex.</p> <p>Angle defect is an discrete approximation of the gaussian curvature. This function relies on the computation of cotangents on the mesh.</p> Warning <p>Only works for triangulated meshes.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh</p> required <code>zero_border</code> <code>bool</code> <p>if set to true, ignores the defect on the boundary of the mesh. Defaults to False.</p> <code>False</code> <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"angleDefect\".</p> <code>'angleDefect'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>Attribute</code> <p>Attribute(float) on vertices</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the mesh is not triangulated (ie if a face is not a triangle)</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_vertices.border_normals","title":"<code>border_normals(mesh, name='borderNormals', persistent=True, dense=False)</code>","text":"<p>Computes the normal direction of the boundary curve.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"borderNormals\".</p> <code>'borderNormals'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>False</code> <p>Returns:</p> Type Description <code>Attribute</code> <p>Attribute(float,3) on vertices</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_vertices.degree","title":"<code>degree(mesh, name='degree', persistent=True, dense=True)</code>","text":"<p>Computes the degree of each vertex, that is the number of vertex that are adjacent.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh. Pointclouds are forbidden</p> required <code>name</code> <code>str</code> <p>description. Defaults to \"degree\".</p> <code>'degree'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>Attribute</code> <p>Attribute(int) on vertices</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_vertices.vertex_normals","title":"<code>vertex_normals(mesh, name='normals', persistent=True, interpolation='area', dense=True, custom_fnormals=None)</code>","text":"<p>Computes normal directions as 3d vectors for each vertex. Normal at a vertex is a weighted sum of normals of adjacent faces. This function essentially interpolates the face normals.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"normals\".</p> <code>'normals'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>interpolation</code> <code>str</code> <p>Interpolation weighting mode. 'uniform' : computes the mean for adjacent facet 'area' : the mean is weighted by facet area. Default value. 'angle' : the mean is weighted by internal angle at the vertex </p> <code>'area'</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <code>custom_fnormals</code> <code>Attribute</code> <p>custom values for the face normals to be interpolated. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>if 'interpolation' is not one of {'uniform', 'area', 'angles'}</p> <p>Returns:</p> Type Description <code>Attribute</code> <p>Attribute(float, 3) on vertices</p>"},{"location":"attributes/per_elements/#edges","title":"Edges","text":""},{"location":"attributes/per_elements/#mouette.attributes.attr_edges.cotan_weights","title":"<code>cotan_weights(mesh, name='cotan_weight', persistent=True, dense=True)</code>","text":"<p>Compute the cotan weights of edges. The weight of an edge separating T1 and T2 is the sum of cotangent of opposite angles in T1 and T2</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh.</p> required <code>name</code> <code>str</code> <p>name of the attribute. Defaults to \"cotan_weight\".</p> <code>'cotan_weight'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code>"},{"location":"attributes/per_elements/#mouette.attributes.attr_edges.curvature_matrices","title":"<code>curvature_matrices(mesh)</code>","text":"<p>Curvature matrix for each edge on the mesh</p> References <p>Restricted Delaunay Triangulations and Normal Cycle, David Cohen-Steiner and Jean-Marie Morvan (2003)</p> Note <p>See Curvature Frame Fields for their aggregation on triangles or vertices</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_edges.edge_length","title":"<code>edge_length(mesh, name='length', persistent=True, dense=True)</code>","text":"<p>Compute edge lengths across the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh. PointClouds are forbidden (no edges).</p> required <code>name</code> <code>str</code> <p>name of the attribute. Defaults to \"length\".</p> <code>'length'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code>"},{"location":"attributes/per_elements/#mouette.attributes.attr_edges.edge_middle_point","title":"<code>edge_middle_point(mesh, name='middle', persistent=True, dense=True)</code>","text":"<p>Compute the middle point of each edge across the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh. PointClouds are forbidden (no edges).</p> required <code>name</code> <code>str</code> <p>name of the attribute. Defaults to \"middle\".</p> <code>'middle'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code>"},{"location":"attributes/per_elements/#faces","title":"Faces","text":""},{"location":"attributes/per_elements/#mouette.attributes.attr_faces.face_area","title":"<code>face_area(mesh, name='area', persistent=True, dense=True)</code>","text":"<p>Computes the barycenter point of each face.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"area\".</p> <code>'area'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>a float per faces</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_faces.face_barycenter","title":"<code>face_barycenter(mesh, name='barycenter', persistent=True, dense=True)</code>","text":"<p>Computes the barycenter point of each face.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"barycenter\".</p> <code>'barycenter'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>one 3D vector per face</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_faces.face_circumcenter","title":"<code>face_circumcenter(mesh, name='circumcenter', persistent=True, dense=True)</code>","text":"<p>Computes the circumcenter point of each triangular face.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"barycenter\".</p> <code>'circumcenter'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>one float per face</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if a face of the mesh is not a triangle</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_faces.face_near_border","title":"<code>face_near_border(mesh, dist=2, name='near_border', persistent=True, dense=False)</code>","text":"<p>Returns a boolean attribute that is True if the face is at most at 'dist' neighbours from the boundary. Proceeds by region growing, starting from all faces touching the boundary and going inwards.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>dist</code> <code>int</code> <p>Extend to which we flag the faces. All faces with a path of length &lt; dist will be set to True. Defaults to 2.</p> <code>2</code> <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"near_border\".</p> <code>'near_border'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>one bool per face.</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_faces.face_normals","title":"<code>face_normals(mesh, name='normals', persistent=True, dense=True)</code>","text":"<p>Computes the barycenter point of each face.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"normals\".</p> <code>'normals'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>3 floats per faces</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_faces.parallel_transport_curvature","title":"<code>parallel_transport_curvature(mesh, PT, name='curvature', persistent=True, dense=True)</code>","text":"<p>Compute the curvature of each face associated to a given parallel transport pT</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <code>PT</code> <code>SurfaceConnectionVertices</code> <p>local bases and parallel transport for vertices.</p> required <code>name</code> <code>str</code> <p>Name given to the attribute.. Defaults to \"curvature\".</p> <code>'curvature'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to False.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <p>One float per face.</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_faces.triangle_aspect_ratio","title":"<code>triangle_aspect_ratio(mesh, name='aspect_ratio', persistent=True, dense=True)</code>","text":"<p>Computes the aspect ratio of every triangular faces. Sets aspect ratio to -1 for every other faces</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"aspect_ratio\".</p> <code>'aspect_ratio'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to False.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>One float per face.</p>"},{"location":"attributes/per_elements/#face-corners","title":"Face Corners","text":""},{"location":"attributes/per_elements/#mouette.attributes.attr_corners.corner_angles","title":"<code>corner_angles(mesh, name='angles', persistent=True, dense=True)</code>","text":"<p>Attribute storing the angles of a face at a vertex</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"angles\".</p> <code>'angles'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>one float per face corner</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_corners.cotangent","title":"<code>cotangent(mesh, name='cotan', persistent=True, dense=True)</code>","text":"<p>Attribute storing the cotangents of each face at each vertex.</p> Warning <p>Only works if the mesh is triangulated (ie every faces are triangles)</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"cotan\".</p> <code>'cotan'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>Attribute</code> <p>Attribute(: one float per face corner</p> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the mesh is not triangulated</p>"},{"location":"attributes/per_elements/#cells","title":"Cells","text":""},{"location":"attributes/per_elements/#mouette.attributes.attr_cells.cell_barycenter","title":"<code>cell_barycenter(mesh, name='barycenter', persistent=True, dense=True)</code>","text":"<p>Computes the barycenter point of each cell.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VolumeMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"barycenter\".</p> <code>'barycenter'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>3D vector per cell</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_cells.cell_faces_on_boundary","title":"<code>cell_faces_on_boundary(mesh, name='boundary', persistent=True, dense=False)</code>","text":"<p>Integer flag on cells. For each cell, computes the number of its faces that lay on the boundary</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VolumeMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"boundary\".</p> <code>'boundary'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>bool per cell</p>"},{"location":"attributes/per_elements/#mouette.attributes.attr_cells.cell_volume","title":"<code>cell_volume(mesh, name='volume', persistent=True, dense=True)</code>","text":"<p>Computes the volume of each cell.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VolumeMesh</code> <p>the input mesh</p> required <code>name</code> <code>str</code> <p>Name given to the attribute. Defaults to \"volume\".</p> <code>'volume'</code> <code>persistent</code> <code>bool</code> <p>If the attribute is persistent (stored in the mesh object) or not. Defaults to True.</p> <code>True</code> <code>dense</code> <code>bool</code> <p>Is the attribute dense (numpy array) or not (dict). Defaults to True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>one float per cell</p>"},{"location":"datastructures/DataContainers/","title":"Data Management","text":"<p><code>mouette</code> is architectured around the concept of data containers, which are containers dedicated to the storage of one type of elements in a mesh and all of its attributes. Data structures in mouette are then defined as collections of specific data containers:</p> <ul> <li> <p>A <code>PointCloud</code> object only has one container named <code>vertices</code> such that <code>object.vertices[i]</code> is a 3D vector containing the position of vertex <code>i</code> in space.</p> </li> <li> <p>In addition to the <code>vertices</code> container, a <code>Polyline</code> object also defines an <code>edges</code> container, which stores pairs of vertex indices.</p> </li> <li> <p>A <code>SurfaceMesh</code> object adds the <code>faces</code> and <code>face_corners</code> containers.</p> </li> <li> <p>Finally, a <code>VolumeMesh</code> objects adds a <code>cells</code> container and two corner containers: <code>cell_corners</code> and <code>cell_faces</code>.</p> </li> </ul>"},{"location":"datastructures/DataContainers/#the-datacontainer-class","title":"The <code>DataContainer</code> class","text":"<p>               Bases: <code>_BaseDataContainer</code></p> <p>A <code>DataContainer</code> is a container class for all elements of the same type in an instance (for example, vertices, edges or faces). It stores relevant information about the combinatorics (in the <code>_data</code> field) as well as various attributes onto the elements (in the <code>_attr</code> field)</p> <p>               Bases: <code>ABC</code></p> <p>Base class for a data container. A container encapsulate all elements of the same type in a mesh as well as attributes defined on them.</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.size","title":"<code>size</code>  <code>property</code>","text":"<p>The container size. Alias for <code>len(container)</code></p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of elements in the container</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Performs several appends for a list of elements</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable | DataContainer</code> <p>a collection of elements to append to the container</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>fails if <code>other</code> is not an iterable</p> <p>Returns:</p> Name Type Description <code>self</code> <p>self</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.append","title":"<code>append(val)</code>","text":"<p>Adds the value 'val' at the end of the container. Also expands all attributes to be able to receive a value for 'val'</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>Any</code> <p>value to append to the container</p> required"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.clear","title":"<code>clear()</code>","text":"<p>Empty the container</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.create_attribute","title":"<code>create_attribute(name, data_type, elem_size=1, dense=False, default_value=None, size=None)</code>","text":"<p>Creates an attribute with name <code>name</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>attribute's name. If 'name' already exists in the attribute dict, the corresponding attribute will be overridden. The override warning can be disabled in the config.</p> required <code>data_type</code> <code>type</code> <p>The type of data stored in the attribute.</p> required <code>elem_size</code> <code>int</code> <p>The number of data per elements. Defaults to 1.</p> <code>1</code> <code>dense</code> <code>bool</code> <p>Whether to create an <code>Attribute</code> object (dictionnary storage) or an <code>ArrayAttribute</code> object (numpy array storage). Defaults to False (dictionnary mode).</p> <code>False</code> <code>default_value</code> <code>Any</code> <p>The default value to fill the attribute with. If not provided, will be taken as the default value of the type <code>data_type</code>. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>Current size of the DataContainer to be passed. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.delete_attribute","title":"<code>delete_attribute(name)</code>","text":"<p>Deletes the attribute associated with name <code>name</code> if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name.</p> required"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.empty","title":"<code>empty()</code>","text":"<p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the container is empty</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.get_attribute","title":"<code>get_attribute(name)</code>","text":"<p>Returns the attribute with name <code>name</code>. Fails if the attribute does not exist</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>no attribute has name <code>name</code> inside this data container.</p> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>the attribute</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.has_attribute","title":"<code>has_attribute(name)</code>","text":"<p>Returns True is an attribute with name <code>name</code> is defined for this container.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.DataContainer.register_array_as_attribute","title":"<code>register_array_as_attribute(name, data, default_value=None)</code>","text":"<p>Converts a numpy array as an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>attribute's name. If 'name' already exists in the attribute dict, the corresponding attribute will be overridden. The override warning can be disabled in the config.</p> required <code>data</code> <code>ndarray</code> <p>the data array. Type of the attribute will be extrapolated from <code>data.dtype</code>.</p> required <code>default_value</code> <code>Any</code> <p>The default value to fill the attribute with. If not provided, will be taken as the default value of the type <code>data_type</code>. Defaults to None.</p> <code>None</code>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container._BaseDataContainer.create_attribute","title":"<code>create_attribute(name, data_type, elem_size=1, dense=False, default_value=None, size=None)</code>","text":"<p>Creates an attribute with name <code>name</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>attribute's name. If 'name' already exists in the attribute dict, the corresponding attribute will be overridden. The override warning can be disabled in the config.</p> required <code>data_type</code> <code>type</code> <p>The type of data stored in the attribute.</p> required <code>elem_size</code> <code>int</code> <p>The number of data per elements. Defaults to 1.</p> <code>1</code> <code>dense</code> <code>bool</code> <p>Whether to create an <code>Attribute</code> object (dictionnary storage) or an <code>ArrayAttribute</code> object (numpy array storage). Defaults to False (dictionnary mode).</p> <code>False</code> <code>default_value</code> <code>Any</code> <p>The default value to fill the attribute with. If not provided, will be taken as the default value of the type <code>data_type</code>. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>Current size of the DataContainer to be passed. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container._BaseDataContainer.delete_attribute","title":"<code>delete_attribute(name)</code>","text":"<p>Deletes the attribute associated with name <code>name</code> if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name.</p> required"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container._BaseDataContainer.get_attribute","title":"<code>get_attribute(name)</code>","text":"<p>Returns the attribute with name <code>name</code>. Fails if the attribute does not exist</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>no attribute has name <code>name</code> inside this data container.</p> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>the attribute</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container._BaseDataContainer.has_attribute","title":"<code>has_attribute(name)</code>","text":"<p>Returns True is an attribute with name <code>name</code> is defined for this container.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container._BaseDataContainer.register_array_as_attribute","title":"<code>register_array_as_attribute(name, data, default_value=None)</code>","text":"<p>Converts a numpy array as an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>attribute's name. If 'name' already exists in the attribute dict, the corresponding attribute will be overridden. The override warning can be disabled in the config.</p> required <code>data</code> <code>ndarray</code> <p>the data array. Type of the attribute will be extrapolated from <code>data.dtype</code>.</p> required <code>default_value</code> <code>Any</code> <p>The default value to fill the attribute with. If not provided, will be taken as the default value of the type <code>data_type</code>. Defaults to None.</p> <code>None</code>"},{"location":"datastructures/DataContainers/#the-special-case-of-corner-containers","title":"The special case of corner containers","text":"<p>               Bases: <code>_BaseDataContainer</code></p> <p>A <code>CornerDataContainer</code> is a variant of a DataContainer for corner elements. It is used for face corners, cell corners and cell faces. </p> <p>Unlike a regular data container that stores a list of simplicial elements, a corner container stores two pieces of information: the associated vertex/face of the corner and the face/cell it belongs to.</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.size","title":"<code>size</code>  <code>property</code>","text":"<p>The container size. Alias for <code>len(container)</code></p> <p>Returns:</p> Name Type Description <code>int</code> <p>number of elements in the container</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Shortcut for self.elem(key)</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int</code> <p>corner identifier</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the vertex or the face this corner points to</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.adj","title":"<code>adj(key)</code>","text":"<p>Returns the mesh element (either face or cell) from which the corner 'key' belongs to</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int</code> <p>identifier of a corner</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>identifier of a face or a cell</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.clear","title":"<code>clear()</code>","text":"<p>Empty the container</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.create_attribute","title":"<code>create_attribute(name, data_type, elem_size=1, dense=False, default_value=None, size=None)</code>","text":"<p>Creates an attribute with name <code>name</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>attribute's name. If 'name' already exists in the attribute dict, the corresponding attribute will be overridden. The override warning can be disabled in the config.</p> required <code>data_type</code> <code>type</code> <p>The type of data stored in the attribute.</p> required <code>elem_size</code> <code>int</code> <p>The number of data per elements. Defaults to 1.</p> <code>1</code> <code>dense</code> <code>bool</code> <p>Whether to create an <code>Attribute</code> object (dictionnary storage) or an <code>ArrayAttribute</code> object (numpy array storage). Defaults to False (dictionnary mode).</p> <code>False</code> <code>default_value</code> <code>Any</code> <p>The default value to fill the attribute with. If not provided, will be taken as the default value of the type <code>data_type</code>. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>Current size of the DataContainer to be passed. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.delete_attribute","title":"<code>delete_attribute(name)</code>","text":"<p>Deletes the attribute associated with name <code>name</code> if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name.</p> required"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.element","title":"<code>element(key)</code>","text":"<p>Returns the mesh element (vertex or face) associated with the corner 'key'</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int</code> <p>identifier of a corner</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>identifier of a vertex or face</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.empty","title":"<code>empty()</code>","text":"<p>Returns:</p> Name Type Description <code>bool</code> <p>whether the container is empty</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.get_attribute","title":"<code>get_attribute(name)</code>","text":"<p>Returns the attribute with name <code>name</code>. Fails if the attribute does not exist</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>no attribute has name <code>name</code> inside this data container.</p> <p>Returns:</p> Name Type Description <code>Attribute</code> <code>Attribute</code> <p>the attribute</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.has_attribute","title":"<code>has_attribute(name)</code>","text":"<p>Returns True is an attribute with name <code>name</code> is defined for this container.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the attribute's name</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code>"},{"location":"datastructures/DataContainers/#mouette.mesh.data_container.CornerDataContainer.register_array_as_attribute","title":"<code>register_array_as_attribute(name, data, default_value=None)</code>","text":"<p>Converts a numpy array as an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>attribute's name. If 'name' already exists in the attribute dict, the corresponding attribute will be overridden. The override warning can be disabled in the config.</p> required <code>data</code> <code>ndarray</code> <p>the data array. Type of the attribute will be extrapolated from <code>data.dtype</code>.</p> required <code>default_value</code> <code>Any</code> <p>The default value to fill the attribute with. If not provided, will be taken as the default value of the type <code>data_type</code>. Defaults to None.</p> <code>None</code>"},{"location":"datastructures/DataContainers/#attributes","title":"Attributes","text":""},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.Attribute","title":"<code>Attribute(elem_type, elem_size=1, default_value=None)</code>","text":"<p>               Bases: <code>_BaseAttribute</code></p> <p>init method and the whole Attribute class are not supposed to be manipulated outside of the DataContainer class</p> <p>Parameters:</p> Name Type Description Default <code>elem_type </code> <p>the type of the attribute (bool, int, float, complex, string)</p> required <code>elem_size</code> <code>int</code> <p>Number of elem_type objects to be stored per element. Defaults to 1.</p> <code>1</code> <code>default_value (optional) </code> <p>the default value of the attribute is n_elem is not specified.  If it is not specified either, it will correspond to the default value of the type provided in elem_type.</p> required"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.Attribute.__iter__","title":"<code>__iter__()</code>","text":"<p>Sparse attributes allow to iterate only over non-default elements</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.Attribute.as_array","title":"<code>as_array(container_size=None)</code>","text":"<p>Converts the attribute to a numpy array</p> <p>Parameters:</p> Name Type Description Default <code>container_size</code> <code>int</code> <p>the total size of the array. Needs to be provided for a dictionnary-based attribute. Ignored for an array-based attribute. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the container size is not provided.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray : attribute as an array over elements.</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.Attribute.clear","title":"<code>clear()</code>","text":"<p>Empties the attribute. Frees the memory and ensures that all access return default value</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.Attribute.empty","title":"<code>empty()</code>","text":"<p>Check if an attribute is empty. For an attribute to be empty, its number of elements should not be fixed, and the dictionnary should be empty</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.ArrayAttribute","title":"<code>ArrayAttribute(elem_type, n_elem, elem_size=1, default_value=None)</code>","text":"<p>               Bases: <code>_BaseAttribute</code></p> <p>init method and the whole Attribute class are not supposed to be manipulated outside of the DataContainer class. An ArrayAttribute stores its values in a numpy array. This is a less flexible but safer approach than Attribute.</p> <p>Parameters:</p> Name Type Description Default <code>elem_type </code> <p>the type of the attribute (bool, int, float, complex, string)</p> required <code>n_elem</code> <code>int</code> <p>Total number of elements in the container. Should match the size of the DataContainer the attribute is stored in.</p> required <code>elem_size</code> <code>int</code> <p>Number of elem_type objects to be stored per element. Defaults to 1.</p> <code>1</code> <code>default_value (optional) </code> <p>the default value of the attribute is n_elem is not specified.  If it is not specified either, it will correspond to the default value of the type provided in elem_type.</p> required"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.ArrayAttribute.__iter__","title":"<code>__iter__()</code>","text":"<p>Sparse attributes allow to iterate only over non-default elements</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.ArrayAttribute.as_array","title":"<code>as_array(*args)</code>","text":"<p>Converts the attribute to a numpy array</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray : attribute as an array over elements.</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.ArrayAttribute.clear","title":"<code>clear()</code>","text":"<p>Empties the attribute. Frees the memory and ensures that all access return default value</p>"},{"location":"datastructures/DataContainers/#mouette.mesh.mesh_attributes.ArrayAttribute.empty","title":"<code>empty()</code>","text":"<p>Check if an attribute is empty. For an attribute to be empty, its number of elements should not be fixed, and the dictionnary should be empty</p>"},{"location":"datastructures/PointClouds/","title":"Point Clouds","text":"Point Cloud of a CAD model <p>A Point Cloud is a simple collection of points in \\(\\mathbb{R}^3\\)</p>"},{"location":"datastructures/PointClouds/#mouette.mesh.datatypes.pointcloud.PointCloud","title":"<code>PointCloud(data=None)</code>","text":"<p>               Bases: <code>Mesh</code></p> <p>A data structure for representing point clouds</p> <p>Attributes:</p> Name Type Description <code>vertices</code> <code>DataContainer</code> <p>the container for all vertices</p> <code>__str__</code> <code>str</code> <p>Representation of the object and its elements as a string.</p>"},{"location":"datastructures/PointClouds/#mouette.mesh.datatypes.pointcloud.PointCloud.id_vertices","title":"<code>id_vertices</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.vertices))</code></p>"},{"location":"datastructures/PointClouds/#mouette.mesh.datatypes.pointcloud.PointCloud.append","title":"<code>append(x)</code>","text":"<p>Shortcut for <code>self.vertices.append(x)</code>, since we can only append elements in the 'vertices' container</p>"},{"location":"datastructures/PolyLines/","title":"Polylines","text":"<p>Polylines are made of vertices (points in 3D space) and edges linking them. They allow to embed a graph in \\(\\mathbb{R}^3\\) and visualize it.</p> <p>Edges are stored in a specific data container called <code>edges</code> as ordered pairs of vertex indices. They are not oriented and the smallest vertex index is always first. For example, \\((1,3)\\) is a valid edge index but \\((3,1)\\) is not. Edge orientation is performed automatically when instancing a <code>Polyline</code> from a <code>RawMeshData</code> (see Edition and Manual Creation)</p> <p> </p> Example of a polyline"},{"location":"datastructures/PolyLines/#polyline","title":"Polyline","text":"<p>               Bases: <code>Mesh</code></p> <p>A data structure for representing polylines.</p> <p>Attributes:</p> Name Type Description <code>vertices</code> <code>DataContainer</code> <p>the container for all vertices</p> <code>edges</code> <code>DataContainer</code> <p>the container for all edges</p> <code>__str__</code> <p>Representation of the object and its elements as a string.</p>"},{"location":"datastructures/PolyLines/#mouette.mesh.datatypes.linear.PolyLine.id_edges","title":"<code>id_edges</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.edges))</code></p>"},{"location":"datastructures/PolyLines/#mouette.mesh.datatypes.linear.PolyLine.id_vertices","title":"<code>id_vertices</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.vertices))</code></p>"},{"location":"datastructures/PolyLines/#polyline-connectivity","title":"Polyline Connectivity","text":"<p>Connectivity handler class. Allows connectivity queries on the object, like neighbours of a vertex, etc.</p> <p>Connectivity is computed lazily only when needed in the code. For instance, the first call to <code>mesh.connectivity.vertex_to_vertices</code> will generate the vertex_to_vertices dictionnary, so that the next call will not perform any computation but a lookup in the array.</p>"},{"location":"datastructures/PolyLines/#mouette.mesh.datatypes.linear.PolyLine._Connectivity.clear","title":"<code>clear()</code>","text":"<p>Resets connectivity.  The next query in the code will regenerate internal arrays.</p>"},{"location":"datastructures/PolyLines/#mouette.mesh.datatypes.linear.PolyLine._Connectivity.edge_id","title":"<code>edge_id(V1, V2)</code>","text":"<p>Identifier of an edge. If <code>self.edges[i]</code> contains edges <code>(A,B)</code>, then <code>edge_id(A,B)=edge_id(B,A)=i</code></p> <p>If (A,B) is not a valid edge of the mesh, returns <code>None</code></p> <p>Parameters:</p> Name Type Description Default <code>V1</code> <code>int</code> <p>first vertex of the edge</p> required <code>V2</code> <code>int</code> <p>second vertex of the edge</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the id of edge (V1,V2), or <code>None</code> if the edge does not exist.</p>"},{"location":"datastructures/PolyLines/#mouette.mesh.datatypes.linear.PolyLine._Connectivity.edge_to_vertices","title":"<code>edge_to_vertices(E)</code>","text":"<p>Returns the two vertex indices that are adjacent to edge `E</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>int</code> <p>edge index</p> required Note <p>Equivalent to <code>mesh.edges[E]</code></p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>two vertex indices</p>"},{"location":"datastructures/PolyLines/#mouette.mesh.datatypes.linear.PolyLine._Connectivity.other_edge_end","title":"<code>other_edge_end(E, V)</code>","text":"<p>Vertex at the opposite end of edge <code>E</code> from vertex <code>V</code>.</p> <p>Returns <code>None</code> if <code>V</code> is not adjacent to edge <code>E</code></p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>int</code> <p>edge id</p> required <code>V</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the vertex <code>W</code> such that <code>E</code> is the edge <code>(V,W)</code>. Returns <code>None</code> if <code>V</code> is not adjacent to edge <code>E</code></p>"},{"location":"datastructures/PolyLines/#mouette.mesh.datatypes.linear.PolyLine._Connectivity.vertex_to_edges","title":"<code>vertex_to_edges(V)</code>","text":"<p>Neighborhood of vertex <code>V</code> in terms of edges.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of edges E such that V belongs to E.</p>"},{"location":"datastructures/PolyLines/#mouette.mesh.datatypes.linear.PolyLine._Connectivity.vertex_to_vertices","title":"<code>vertex_to_vertices(V)</code>","text":"<p>Neighborhood of vertex <code>V</code> in terms of vertices.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of vertices <code>W</code> such that <code>(V,W)</code> is a valid edge in the polyline.</p>"},{"location":"datastructures/SurfaceMeshes/","title":"Surface meshes","text":"A triangular surface mesh"},{"location":"datastructures/SurfaceMeshes/#surfacemesh","title":"SurfaceMesh","text":"<p>               Bases: <code>Mesh</code></p> <p>A data structure for representing polygonal surfaces.</p> <p>Attributes:</p> Name Type Description <code>vertices</code> <code>DataContainer</code> <p>the container for all vertices</p> <code>edges</code> <code>DataContainer</code> <p>the container for all edges</p> <code>faces</code> <code>DataContainer</code> <p>the container for all faces</p> <code>face_corners</code> <code>DataContainer</code> <p>the container for all corner of faces</p> <code>boundary_edges</code> <code>list</code> <p>list of all edge indices on the boundary</p> <code>interior_edges</code> <code>list</code> <p>list of all interior edge indices (all edges \\ boundary_edges)</p> <code>boundary_vertices</code> <code>list</code> <p>list of all vertex indices on the boundary</p> <code>interior_vertices</code> <code>list</code> <p>list of all interior verticex indices (all vertices \\ boundary_vertices)</p> <code>connectivity</code> <code>_SurfaceConnectivity</code> <p>the connectivity utility class</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.id_corners","title":"<code>id_corners</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.face_corners))</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.id_edges","title":"<code>id_edges</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.edges))</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.id_faces","title":"<code>id_faces</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.faces))</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.id_vertices","title":"<code>id_vertices</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.vertices))</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.clear_boundary_data","title":"<code>clear_boundary_data()</code>","text":"<p>Clear all boundary data. Next call to a boundary/interior container or method will recompute everything</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.is_edge_on_border","title":"<code>is_edge_on_border(u, v)</code>","text":"<p>whether edge (u,v) is a boundary edge or not</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int</code> <p>vertex id</p> required <code>v</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether edge (u,v) is a boundary edge or not. Returns False if (u,v) is not a valid edge.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.is_quad","title":"<code>is_quad()</code>","text":"<p>Checks if the mesh is a quadrangulation</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the mesh is quadrangular (all faces are quad)</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.is_triangular","title":"<code>is_triangular()</code>","text":"<p>Checks if the mesh is a triangulation</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the mesh is triangular (all faces are triangles)</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.is_vertex_on_border","title":"<code>is_vertex_on_border(u)</code>","text":"<p>whether vertex <code>u</code> is a boundary vertex or not.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether vertex <code>u</code> is a boundary vertex or not.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.ith_vertex_of_face","title":"<code>ith_vertex_of_face(fid, i)</code>","text":"<p>helper function to get the i-th vertex of a face, i.e. <code>self.faces[fid][i]</code></p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>face id</p> required <code>i</code> <code>int</code> <p>vertex id in face. Should be 0 &lt;= vid &lt; len(face)</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the id of the i-th vertex in face <code>fid</code> (<code>self.faces[fid][i]</code>)</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh.pt_of_face","title":"<code>pt_of_face(fid)</code>","text":"<p>point coordinates of vertices of face <code>fid</code></p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>face id</p> required <p>Returns:</p> Name Type Description <code>Iterable</code> <p>iterator of Vec objects representing point coordinates of vertices</p>"},{"location":"datastructures/SurfaceMeshes/#surface-connectivity","title":"Surface Connectivity","text":"<p>               Bases: <code>_Connectivity</code></p> <p>Connectivity for surface meshes. Is accessed via the <code>.connectivity</code> attribute of the <code>SurfaceMesh</code> class.</p> Warning <p>If your mesh is not manifold, there is no guarantee that the connectivity arrays will be correct.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.clear","title":"<code>clear()</code>","text":"<p>Resets connectivity.  The next query in the code will regenerate internal arrays.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.common_edge","title":"<code>common_edge(iF1, iF2)</code>","text":"<p>Returns the two vertices (u,v) of the edge that separates faces iF1 and iF2 if it exists, and (None,None) otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>iF1</code> <code>int</code> <p>first face index</p> required <code>iF2</code> <code>int</code> <p>second face index</p> required <p>Returns:</p> Type Description <code>(int, int)</code> <p>(u,v) pair of vertex indices, or (None,None)</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.corner_to_face","title":"<code>corner_to_face(C)</code>","text":"<p>The face inside which corner <code>C</code> belongs.</p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>int</code> <p>corner id</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>face id</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.corner_to_half_edge","title":"<code>corner_to_half_edge(C)</code>","text":"<p>Half edge (A -&gt; B) associated with corner C</p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>int</code> <p>corner index</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(int, int)</code> <p>the two vertex indices of the half edge</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.direct_face","title":"<code>direct_face(u, v, return_inds=False)</code>","text":"<p>Pair (u,v) of vertex -&gt; triangle to the left of edge (u,v) if edge (u,v) exists, None otherwise Also returns local indexes of u and v in the triangle (and None if (u,v) does not exists)</p> <p>Calling this function with edge (v,u) yield the triangle of the other side of the edge</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int</code> <p>first vertex index</p> required <code>v</code> <code>int</code> <p>second vertex index</p> required <code>return_inds</code> <code>bool</code> <p>Whether to return local indices of u and v in the face. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>Index of a face or None. If return_inds is True, tuple made of index of face and local indices of u and v in face or (None,None,None).</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.edge_id","title":"<code>edge_id(V1, V2)</code>","text":"<p>Identifier of an edge. If <code>self.edges[i]</code> contains edges <code>(A,B)</code>, then <code>edge_id(A,B)=edge_id(B,A)=i</code></p> <p>If (A,B) is not a valid edge of the mesh, returns <code>None</code></p> <p>Parameters:</p> Name Type Description Default <code>V1</code> <code>int</code> <p>first vertex of the edge</p> required <code>V2</code> <code>int</code> <p>second vertex of the edge</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the id of edge (V1,V2), or <code>None</code> if the edge does not exist.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.edge_to_faces","title":"<code>edge_to_faces(u, v)</code>","text":"<p>For an edge <code>(u,v)</code>, returns the indices of faces that are direct and indirect from <code>(u,v)</code>(see <code>direct_face</code> method). If one of the faces does not exist, returns a <code>None</code> instead of its index.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int</code> <p>index of first vertex</p> required <code>v</code> <code>int</code> <p>index of second vertex</p> required"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.edge_to_vertices","title":"<code>edge_to_vertices(E)</code>","text":"<p>Returns the two vertex indices that are adjacent to edge `E</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>int</code> <p>edge index</p> required Note <p>Equivalent to <code>mesh.edges[E]</code></p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>two vertex indices</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.face_id","title":"<code>face_id(*args)</code>","text":"<p>The identifier of a face.</p> <p>Parameters:</p> Name Type Description Default <code>int*</code> <p>integers representing indices of vertices of the face (not necessarily in the correct order)</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A face index or None if the given tuple is invalid</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.face_to_corners","title":"<code>face_to_corners(F)</code>","text":"<p>list of corners of face <code>F</code></p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>int</code> <p>face id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of corners of face <code>F</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.face_to_edges","title":"<code>face_to_edges(F)</code>","text":"<p>List of edges that bound face <code>F</code>.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>int</code> <p>face id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of edges <code>E</code> such that <code>E</code> is a boundary edge of face <code>F</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.face_to_faces","title":"<code>face_to_faces(F)</code>","text":"<p>List of faces that are adjacent to face <code>F</code></p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>int</code> <p>face id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of faces <code>G</code> that are adjacent to <code>F</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.face_to_first_corner","title":"<code>face_to_first_corner(F)</code>","text":"<p>One corner <code>C</code> of the face <code>F</code> (the first in order of appearance in the <code>face_corners</code> container)</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>int</code> <p>face id</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>corner id</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.face_to_vertices","title":"<code>face_to_vertices(F)</code>","text":"<p>Neighborhood of face <code>F</code> in terms of vertices.</p> Note <p>Equivalent to <code>mesh.faces[F]</code></p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>int</code> <p>face id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of vertices <code>V</code> such that <code>V</code> is a vertex of <code>F</code>.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.in_face_index","title":"<code>in_face_index(F, V)</code>","text":"<p>Index of vertex V in face F. None if V is not in face F</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>int</code> <p>face index</p> required <code>V</code> <code>int</code> <p>vertex index</p> required <p>Returns:</p> Type Description <p>int</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.next_corner","title":"<code>next_corner(C)</code>","text":"<p>Next corner of <code>C</code> around its associated face</p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>int</code> <p>corner index</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>index of the next corner</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.opposite_corner","title":"<code>opposite_corner(C)</code>","text":"<p>Opposite corner of <code>C</code> in terms of half edges.  If <code>C.vertex = A</code> and <code>C.next.vertex = B</code>, then returns the corner D such that <code>D.vertex = B</code> and <code>D.vertex.next = A</code></p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>int</code> <p>corner index</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>index of the opposite corner</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.opposite_face","title":"<code>opposite_face(u, v, F, return_inds=False)</code>","text":"<p>Returns the index of the face adjacent to edge <code>(u,v)</code> that is at the opposite of face <code>F</code>. Returns <code>None</code> if such a face does not exist, or if <code>F</code> is not adjacent to edge <code>(u,v)</code></p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int</code> <p>index of edge's first vertex</p> required <code>v</code> <code>int</code> <p>index of edge's second vertex</p> required <code>F</code> <code>int</code> <p>index of face</p> required <code>return_inds</code> <code>bool</code> <p>If True, also returns local indices of <code>u</code> and <code>v</code> in opposite face. If input is invalid, will return <code>None,None,None</code> instead of <code>None</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <p>index of a face</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.other_edge_end","title":"<code>other_edge_end(E, V)</code>","text":"<p>Vertex at the opposite end of edge <code>E</code> from vertex <code>V</code>.</p> <p>Returns <code>None</code> if <code>V</code> is not adjacent to edge <code>E</code></p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>int</code> <p>edge id</p> required <code>V</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the vertex <code>W</code> such that <code>E</code> is the edge <code>(V,W)</code>. Returns <code>None</code> if <code>V</code> is not adjacent to edge <code>E</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.previous_corner","title":"<code>previous_corner(C)</code>","text":"<p>Previous corner of <code>C</code> around its associated face</p> <p>Parameters:</p> Name Type Description Default <code>C</code> <code>int</code> <p>corner index</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>index of the previous corner</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.vertex_to_corner_in_face","title":"<code>vertex_to_corner_in_face(V, F)</code>","text":"<p>The corner <code>C</code> corresponding to vertex <code>V</code> in face <code>F</code>.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>int</code> <p>vertex id</p> required <code>F</code> <code>int</code> <p>face id</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>corner id, or <code>None</code> if <code>V</code> is not a vertex of <code>F</code>.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.vertex_to_corners","title":"<code>vertex_to_corners(V)</code>","text":"<p>List of face corners that correspond to vertex <code>V</code></p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the list of corners <code>C</code> such that <code>mesh.corners[C]==V</code></p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.vertex_to_edges","title":"<code>vertex_to_edges(V)</code>","text":"<p>Neighborhood of vertex <code>V</code> in terms of edges.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of edges E such that V belongs to E.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.vertex_to_faces","title":"<code>vertex_to_faces(V)</code>","text":"<p>Neighborhood of vertex <code>V</code> in terms of faces.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of faces <code>F</code> such that <code>V</code> is a vertex of <code>F</code>.</p>"},{"location":"datastructures/SurfaceMeshes/#mouette.mesh.datatypes.surface.SurfaceMesh._Connectivity.vertex_to_vertices","title":"<code>vertex_to_vertices(V)</code>","text":"<p>Neighborhood of vertex <code>V</code> in terms of vertices.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>int</code> <p>vertex id</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of vertices <code>W</code> such that <code>(V,W)</code> is a valid edge in the polyline.</p>"},{"location":"datastructures/VolumeMeshes/","title":"Volume meshes","text":"A tetrahedral mesh"},{"location":"datastructures/VolumeMeshes/#volumemesh","title":"VolumeMesh","text":"<p>               Bases: <code>Mesh</code></p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.boundary_mesh","title":"<code>boundary_mesh</code>  <code>property</code>","text":"<p>The boundary of the VolumeMesh as a SurfaceMesh. Shortcut for `self.boundary_connectivity.mesh</p> <p>Returns:</p> Name Type Description <code>None</code> <p>if the boundary connectivity is not enabled (mesh was not built). See <code>enable_connectivity</code></p> <code>SurfaceMesh</code> <p>the boundary mesh otherwise</p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.id_cells","title":"<code>id_cells</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.cells))</code></p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.id_corners","title":"<code>id_corners</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.face_corners))</code></p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.id_edges","title":"<code>id_edges</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.edges))</code></p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.id_faces","title":"<code>id_faces</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.faces))</code></p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.id_vertices","title":"<code>id_vertices</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.vertices))</code></p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.enable_boundary_connectivity","title":"<code>enable_boundary_connectivity()</code>","text":"<p>Builds the indirection maps to the boundary surface mesh, which then can be accessed via the <code>self.boundary_connectivity</code> attribute.</p> <p>See documentation for VolumeMesh._BoundaryConnectivity for more details.</p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.is_cell_tet","title":"<code>is_cell_tet(ic)</code>","text":"<p>Returns <code>True if the cell given by id</code>ic` is a tetrahedron (i.e. has 4 vertices)</p> <p>Parameters:</p> Name Type Description Default <code>ic</code> <code>int</code> <p>cell index</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>len(self.cells[ic])==4</p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.is_edge_on_border","title":"<code>is_edge_on_border(*args)</code>","text":"<p>Simple test to determine if a given edge is on the boundary of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Either an integer index representing an edge, or two integer indices representing two (adjacent) vertices</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the given edge is on the boundary of the mesh.</p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.is_face_on_border","title":"<code>is_face_on_border(*args)</code>","text":"<p>Simple test to determine if a given face is on the boundary of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Either an integer index representing a face, or n integer indices representing the vertices</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True is the given face exists and is on the boundary of the mesh</p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh.is_tetrahedral","title":"<code>is_tetrahedral()</code>","text":"<p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the mesh is tetrahedral (all cells are tetrahedra)</p>"},{"location":"datastructures/VolumeMeshes/#volume-connectivity","title":"Volume Connectivity","text":"<p>Warning</p> <p>Volume connectivity is a work in progress and will be available soon.</p>"},{"location":"datastructures/VolumeMeshes/#boundaryconnectivity","title":"BoundaryConnectivity","text":"<p>In some applications, you may need to access the boundary surface mesh of a volume mesh in a self-contained way while keeping links to the original volume. It allows requests like \"return the list of all vertices adjacent to boundary vertex i that are on the boundary\"</p> <p>It implements the same methods as the Connectivity class of surface meshes for the boundary mesh, as well as indirection arrays to move from volume indices to surface indices. Returned indices of connectivity queries are indices with relation to the volume mesh.</p> <p>To save time and memory, the boundary indirections are not computed by default. Use the <code>enable_boundary_connectivity()</code> method of the <code>VolumeMesh</code> to explicitly generate a <code>BoundaryConnectivity</code> object, stored in the <code>.boundary_connectivity</code> attribute.</p> <p>Example</p> <pre><code>import mouette as M\nm = M.mesh.load(\"my_volume_mesh.tet\")\n\n# if enable_boundary_connectivity is not called, `m.boundary_connectivity` is None\nm.enable_boundary_connectivity() # builds the indirection\nbnd_m = m.boundary_mesh # access the boundary mesh as an independent surface mesh\nboundary_neighbors = m.boundary_connectivity.vertex_to_vertices(4) # query connectivity\n</code></pre> <p>               Bases: <code>_Connectivity</code></p> <p>Attributes:</p> Name Type Description <code>m2b_vertex</code> <code>dict</code> <p>volume mesh -&gt; boundary indirection for vertices</p> <code>m2b_edge</code> <code>dict</code> <p>volume mesh -&gt; boundary indirection for edges</p> <code>m2b_face</code> <code>dict</code> <p>volume mesh -&gt; boundary indirection for faces</p> <code>b2m_vertex</code> <code>dict</code> <p>boundary -&gt; volume mesh indirection for vertices</p> <code>b2m_edge</code> <code>dict</code> <p>boundary -&gt; volume mesh indirection for edges</p> <code>b2m_face</code> <code>dict</code> <p>boundary -&gt; volume mesh indirection for faces</p>"},{"location":"datastructures/VolumeMeshes/#mouette.mesh.datatypes.volume.VolumeMesh._BoundaryConnectivity.clear","title":"<code>clear()</code>","text":"<p>Resets connectivity.  The next query in the code will regenerate internal arrays.</p>"},{"location":"manipulating_data/boundary_extraction/","title":"Boundary Extraction","text":""},{"location":"manipulating_data/boundary_extraction/#mouette.processing.border.extract_border_cycle","title":"<code>extract_border_cycle(mesh, starting_point=None)</code>","text":"<p>Extracts a list of vertices that are on the border of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh</p> required <code>starting_point</code> <code>int</code> <p>Origin point. Should be on border</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>list of vertices on border in order</p> <code>list</code> <p>list of edges on border in order</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Fails if 'starting_point' not on the border</p>"},{"location":"manipulating_data/boundary_extraction/#mouette.processing.border.extract_border_cycle_all","title":"<code>extract_border_cycle_all(mesh)</code>","text":"<p>Extracts all the border cycles of a mesh and returns a list of list of vertices</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh</p> required <p>Returns:</p> Type Description <code>list</code> <p>list of list of vertices</p>"},{"location":"manipulating_data/boundary_extraction/#mouette.processing.border.extract_boundary_of_surface","title":"<code>extract_boundary_of_surface(mesh)</code>","text":"<p>Returns the boundary of a surface mesh as a polyline</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>boundary curves of the mesh</p> <code>dict</code> <code>PolyLine</code> <p>maps a vertex id in the boundary to its corresponding id in the original mesh.</p>"},{"location":"manipulating_data/boundary_extraction/#mouette.processing.border.extract_boundary_of_volume","title":"<code>extract_boundary_of_volume(mesh)</code>","text":"<p>Returns the boundary of a volume mesh as a surface mesh</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VolumeMesh</code> <p>input mesh</p> required <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the boundary as a SurfaceMesh</p> <code>dict</code> <code>SurfaceMesh</code> <p>maps a vertex id in the boundary to its corresponding id in the original mesh.</p> <code>dict</code> <code>SurfaceMesh</code> <p>maps a vertex id from the original mesh to its corresponding id in the boundary mesh.</p>"},{"location":"manipulating_data/editing/","title":"Edition and Manual Creation","text":"<p>Alongside loading and saving various file formats, <code>mouette</code> allows to create datastructures from scratch. This can be done using the <code>RawMeshData</code> class. This class possesses all possible data containers available in mouette but no connectivity or functionnality: it is purely a storage class. The user can append its data to the corresponding containers:</p> <pre><code>data = M.mesh.RawMeshData()\n# use += instead of append to add several elements\ndata.vertices += [[0,0,0],[1,2,3],[1,-1,0],[0,1,-2]] \ndata.edges.append((0,2))\ndata.faces.append((0,1,2))\ndata.faces.append((0,1,3))\n</code></pre> <p>When all operations are done, the <code>RawMeshData</code> object can be passed as an argument to the constructor of a <code>PointCloud</code>, <code>Polyline</code>, <code>SurfaceMesh</code> or <code>VolumeMesh</code> object. This will sanitize the data under the hood and generate eventual corner data:</p> <pre><code># Create the SurfaceMesh object. \n# This sanitizes the data under the hood and generates edges and face corners\nsurface = M.mesh.SurfaceMesh(data) \n</code></pre> <p>Warning</p> <p>Do not directly append elements to containers of a <code>SurfaceMesh</code> or <code>VolumeMesh</code>, as this can create connectivity issues. <code>PointCloud</code> and <code>Polyline</code> are usually safe but using <code>RawMeshData</code> in all cases is the recommanded approach.</p> <p>For example, this code will create connectivity issues as the corresponding face corners will not be generated: <pre><code>surface = M.mesh.SurfaceMesh()\nsurface.vertices += [[0,0,0],[1,2,3],[1,-1,0],[0,1,-2]]\nsurface.faces.append((0,1,2))\nsurface.faces.append((0,1,3)) # This does not generate face corners correctly \n</code></pre></p> <p>While this is correct <pre><code>raw_surface = M.mesh.RawMeshData()\nraw_surface.vertices += [[0,0,0],[1,2,3],[1,-1,0],[0,1,-2]]\nraw_surface.faces.append((0,1,2))\nraw_surface.faces.append((0,1,3)) \nsurface = M.mesh.SurfaceMesh(raw_surface) # This will create everything\n</code></pre></p>"},{"location":"manipulating_data/editing/#rawmeshdata","title":"RawMeshData","text":"<p>A base container class to store all the data relative to a mesh. Serves an intermediate between io parsers or manual inputs and instantiated (and typed) mesh classes.</p>"},{"location":"manipulating_data/editing/#mouette.mesh.mesh_data.RawMeshData.dimensionality","title":"<code>dimensionality</code>  <code>property</code>","text":"<p>Dimensionality of the manifold represented by the data.</p> <ul> <li> <p>If only vertices -&gt; 0</p> </li> <li> <p>If vertices and edges (embedded graph) -&gt; 1</p> </li> <li> <p>If faces (surface manifold) -&gt; 2</p> </li> <li> <p>If cells (volume manifold) -&gt; 3</p> </li> </ul> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>0,1,2 or 3</p>"},{"location":"manipulating_data/editing/#mouette.mesh.mesh_data.RawMeshData.id_cellcorners","title":"<code>id_cellcorners</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.cell_corners))</code></p>"},{"location":"manipulating_data/editing/#mouette.mesh.mesh_data.RawMeshData.id_cells","title":"<code>id_cells</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.cells))</code></p>"},{"location":"manipulating_data/editing/#mouette.mesh.mesh_data.RawMeshData.id_edges","title":"<code>id_edges</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.edges))</code></p>"},{"location":"manipulating_data/editing/#mouette.mesh.mesh_data.RawMeshData.id_facecorners","title":"<code>id_facecorners</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.face_corners))</code></p>"},{"location":"manipulating_data/editing/#mouette.mesh.mesh_data.RawMeshData.id_faces","title":"<code>id_faces</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.faces))</code></p>"},{"location":"manipulating_data/editing/#mouette.mesh.mesh_data.RawMeshData.id_vertices","title":"<code>id_vertices</code>  <code>property</code>","text":"<p>Shortcut for <code>range(len(self.vertices))</code></p>"},{"location":"manipulating_data/editing/#mouette.mesh.mesh_data.RawMeshData.prepare","title":"<code>prepare()</code>","text":"<p>Prepares the data to have the correct format. This method is called by the constructors of data structures.</p> <p>First generates explicitely the set of faces from cells and the set of edges from faces.  This behavior can be controlled via the <code>config.complete_faces_from_cells</code> and  the <code>config.complete_edges_from_faces</code> global config variables.</p> <p>Then, treatments are applied on each DataContainer:</p> <ul> <li> <p>On vertices : casts 3D vectors to <code>mouette.Vec</code></p> </li> <li> <p>On edges : sorts edge tuples to satisfy edge convention (smallest index first)</p> </li> <li> <p>On faces : nothing</p> </li> <li> <p>On face corners : generates the face_corners container if empty</p> </li> <li> <p>On cells : nothing</p> </li> <li> <p>On cell corners : generates the cell_corners container if empty</p> </li> </ul>"},{"location":"manipulating_data/loading/","title":"Loading and Saving Meshes","text":""},{"location":"manipulating_data/loading/#mouette.mesh.mesh.copy","title":"<code>copy(mesh, copy_attributes=False, copy_connectivity=False)</code>","text":"<p>Makes a copy of the input mesh</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>input mesh</p> required <code>copy_attributes</code> <code>bool</code> <p>whether to also copy attributes data. Defaults to False.</p> <code>False</code> <code>copy_connectivity</code> <code>bool</code> <p>whether to also copy the connectivity data. Defaults to False.</p> <code>False</code> <p>Returns:     Mesh: a hard copy of the given mesh</p>"},{"location":"manipulating_data/loading/#mouette.mesh.mesh.from_arrays","title":"<code>from_arrays(V, E=None, F=None, C=None, raw=False)</code>","text":"<p>Creates a mesh object from numpy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>ndarray</code> <p>vertex coordinates. SHould have shape |V|3 or |V|2. If shape |V|*2, the array is padded so that z=0.</p> required <code>E</code> <code>ndarray</code> <p>Edge indices (shape |E|*2). Defaults to None.</p> <code>None</code> <code>F</code> <code>ndarray</code> <p>Face indices (shape |F|*n for n-regular faces). Defaults to None.</p> <code>None</code> <code>C</code> <code>ndarray</code> <p>Cell indices (shape |C|*n for n-regular cells). Defaults to None.</p> <code>None</code> <code>raw</code> <code>bool</code> <p>Returns the RawMeshData object instead of a fully prepared Mesh object. Defaults to False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>a mesh object (PointCloud to VolumeMesh depending on the data provided)</p>"},{"location":"manipulating_data/loading/#mouette.mesh.mesh.load","title":"<code>load(filename, dim=None, raw=False)</code>","text":"<p>Loads a Mesh object from a file on the disk.</p> <p>Supported file formats are:</p> <ul> <li> <p>wavefront (.obj)</p> </li> <li> <p>medit (.mesh)</p> </li> <li> <p>geogram (.geogram_ascii)</p> </li> <li> <p>.ply</p> </li> <li> <p>.stl</p> </li> <li> <p>.off</p> </li> <li> <p>.tet</p> </li> <li> <p>.xyz (point clouds only)</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the path of the file</p> required <code>dim</code> <code>int</code> <p>Override for the dimensionality of the resulting mesh. Depending on this value, returns a PointCloud, LineMesh, SurfaceMesh or VolumeMesh.  If not specified, computed from the data read in the file.</p> <code>None</code> <code>raw</code> <code>bool</code> <p>Returns the RawMeshData object instead of a fully prepared Mesh object. Defaults to False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>A new mesh object (PointCloud, LineMesh, SurfaceMesh or VolumeMesh)</p>"},{"location":"manipulating_data/loading/#mouette.mesh.mesh.merge","title":"<code>merge(mesh_list)</code>","text":"<p>Merges a list of independents meshes as a unique mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh_list</code> <code>list</code> <p>a list of meshes. If empty, this function returns None</p> required <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>the merged mesh. Takes the type of the mesh with the largest dimensionality in the list (ie merging a Polyline with a Volume mesh returns a Volume mesh)</p>"},{"location":"manipulating_data/loading/#mouette.mesh.mesh.reorder_vertices","title":"<code>reorder_vertices(mesh, new_indices)</code>","text":"<p>Reorders vertex indices in a mesh object.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>input mesh</p> required <code>new_indices</code> <code>list</code> <p>a list containing a permutation of vertices. New index of vertex L[i] will be i.</p> required <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>the mesh object with permuted vertices</p>"},{"location":"manipulating_data/loading/#mouette.mesh.mesh.save","title":"<code>save(mesh, filename, ignore_elements=None)</code>","text":"<p>Saves the mesh data into a file.</p> <p>Supported file formats are:</p> <ul> <li> <p>wavefront (.obj)</p> </li> <li> <p>medit (.mesh)</p> </li> <li> <p>geogram (.geogram_ascii)</p> </li> <li> <p>.ply</p> </li> <li> <p>.stl</p> </li> <li> <p>.off</p> </li> <li> <p>.tet</p> </li> <li> <p>.xyz (point clouds only)</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The output file path</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Unsupported file extension</p>"},{"location":"manipulating_data/procedural/","title":"Procedural Generation","text":"<p>The <code>mouette.procedural</code> module implements various functions to generate surface meshes or various shapes directly from code</p> <p> </p> Shapes generated procedurally with mouette"},{"location":"manipulating_data/procedural/#procedural-shapes","title":"Procedural shapes","text":""},{"location":"manipulating_data/procedural/#mouette.procedural.flat.triangle","title":"<code>triangle(P0, P1, P2)</code>","text":"<p>Generates a triangle from three vertices</p> <p>Parameters:</p> Name Type Description Default <code>P0,P1,P2</code> <code>Vec</code> <p>three points</p> required <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a triangle</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.flat.unit_triangle","title":"<code>unit_triangle(nu, nv, generate_uvs=False)</code>","text":"<p>Generate a subdivided unit right triangle (half of a unit grid)</p> <p>Parameters:</p> Name Type Description Default <code>nu</code> <code>int</code> <p>number of subdivisions on the horizontal axis</p> required <code>nv</code> <code>int</code> <p>number of subdivisions on the vertical axis</p> required <code>generate_uvs</code> <code>bool</code> <p>whether to generate uv-coordinates. Defaults to False.</p> <code>False</code> <p>Returns     SurfaceMesh: a subdivided unit triangle</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.flat.quad","title":"<code>quad(P0, P1, P2, triangulate=False)</code>","text":"<p>Generates a quad from three vertices</p> <pre><code>   P1-------\n  /        /\n /        / \nP0-------P2  \n</code></pre> <p>Parameters:</p> Name Type Description Default <code>P0,P1,P2</code> <code>Vec</code> <p>coordinates of corners. The fourth point is deduced as P2 + P1 - 2*P0</p> required <code>triangulate</code> <code>bool</code> <p>whether to output two triangles instead of a quad. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a quad</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.flat.unit_grid","title":"<code>unit_grid(nu, nv, triangulate=False, generate_uvs=False)</code>","text":"<p>Generates a subdivided regular unit grid</p> <p>Parameters:</p> Name Type Description Default <code>nu</code> <code>int</code> <p>number of subdivisions on the horizontal axis</p> required <code>nv</code> <code>int</code> <p>number of subdivisions on the vertical axis</p> required <code>triangulate</code> <code>bool</code> <p>whether to split quads into two triangles. Defaults to False.</p> <code>False</code> <code>generate_uvs</code> <code>bool</code> <p>whether to generate uv-coordinates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a subdivided unit grid of size nu*nv</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.rings.ring","title":"<code>ring(N, defect, open=False, n_cover=1)</code>","text":"<p>Computes a ring of triangles with prescribed number of triangles and angle defect at the center.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>number of triangles in the ring</p> required <code>defect</code> <code>float</code> <p>target angle defect to achieve. Position of the central point is adjusted via dichotomy to match this value.</p> required <code>open (bool) </code> <p>whether to connect the last vertex to the first.</p> required <code>n_cover</code> <code>int</code> <p>Number of covering of the ring. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Fails if N&lt;3</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the ring</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.rings.flat_ring","title":"<code>flat_ring(N, defect, n_cover=1)</code>","text":""},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.tetrahedron","title":"<code>tetrahedron(P1, P2, P3, P4, volume=False)</code>","text":"<p>Simple tetrahedron from four points</p> <p>Parameters:</p> Name Type Description Default <code>P1</code> <code>Vec</code> <p>first point</p> required <code>P2</code> <code>Vec</code> <p>second point</p> required <code>P3</code> <code>Vec</code> <p>third point</p> required <code>P4</code> <code>Vec</code> <p>fourth point</p> required <code>volume</code> <code>bool</code> <p>whether to generate a cell or just a surface. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>description</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.hexahedron","title":"<code>hexahedron(P1, P2, P3, P4, P5, P6, P7, P8, colored=False, triangulate=False, volume=False)</code>","text":"<p>Generate an hexahedron in arbitrary configuration given 8 points. Order and connectivity of points is:</p> <pre><code>   7--------6\n  /|       /|\n / |      / |\n4--------5  |\n|  |     |  |\n|  3-----|--2\n| /      | /\n|/       |/\n0--------1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>P1 to P8</code> <code>Vec</code> <p>coordinates of eight vertices</p> required <code>colored</code> <code>bool</code> <p>if set to true, will add a color attribute on faces. Defaults to False.</p> <code>False</code> <code>triangulate</code> <code>bool</code> <p>if set to true, will triangulate the faces. Defaults to False.</p> <code>False</code> <code>volume</code> <code>bool</code> <p>if set to true, will also generate three tetrahedra to fill the volume. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a cube</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.hexahedron_4pts","title":"<code>hexahedron_4pts(P1, P2, P3, P4, colored=False, volume=False)</code>","text":"<p>Generate an hexahedron given by an absolute position and three points building a basis.</p> <pre><code>4\n|\n|  3\n| /\n|/\n1--------2\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>P1 to P4</code> <code>Vec</code> <p>coordinates of vertices</p> required <code>colored</code> <code>bool</code> <p>if set to true, will add a color attribute on faces to determine. Defaults to False.</p> <code>False</code> <code>volume</code> <code>bool</code> <p>if set to true, will also generate three tetrahedra to fill the volume. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>[description]</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.axis_aligned_cube","title":"<code>axis_aligned_cube(colored=False, triangulate=False)</code>","text":"<p>generated an axis aligned cube as 6 quad faces.</p> <pre><code>   7--------6\n  /|       /|\n / |      / |\n4--------5  |\n|  |     |  |\n|  3-----|--2\n| /      | /\n|/       |/\n0--------1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>colored</code> <code>bool</code> <p>if set to true, will add a colo rattribute on faces to determine. Defaults to False.</p> <code>False</code> <code>triangulate</code> <code>bool</code> <p>if set to true, will triangulate the faces. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a cube</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.octahedron","title":"<code>octahedron()</code>","text":"<p>Generate a unit octahedron as the dual mesh of the unit hexahedron</p> Reference <p>https://danielsieger.com/blog/2021/01/03/generating-platonic-solids.html</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.icosahedron","title":"<code>icosahedron(center=Vec(0, 0, 0), radius=1.0, uv=False)</code>","text":"<p>Generate a unit icosahedron</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Vec</code> <p>center position. Defaults to Vec(0,0,0).</p> <code>Vec(0, 0, 0)</code> <code>uv</code> <code>bool</code> <p>whether to generate uv coordinates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.dodecahedron","title":"<code>dodecahedron()</code>","text":"<p>Generate a unit dodecahedron as the dual mesh of an icosahedron</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a dodecahedron</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.cylinder","title":"<code>cylinder(P1, P2, radius=1.0, N=50, fill_caps=True)</code>","text":"<p>Generates a cylinder around the segment defined by P1 and P2</p> <p>Parameters:</p> Name Type Description Default <code>P1</code> <code>Vec</code> <p>start of the cylinder (center of bottom face)</p> required <code>P2</code> <code>Vec</code> <p>end of the cylinder (center of top face)</p> required <code>radius</code> <code>float</code> <p>radius. Defaults to 1..</p> <code>1.0</code> <code>N</code> <code>int</code> <p>number of segments. Defaults to 50.</p> <code>50</code> <code>fill_caps</code> <code>bool</code> <p>whether to also generate faces at caps. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a cylinder</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.torus","title":"<code>torus(major_segments=50, minor_segments=30, major_radius=1.0, minor_radius=0.3, triangulate=False)</code>","text":"<p>Generates a torus Args:     major_segments (int): number of major segments. Defaults to 50.     minor_segments (int): number of minor segments. Defaults to 30.     major_radius (float): global radius of the torus. Defaults to 1.     minor_radius (float): thickness of the torus. Defaults to 0.3     triangulate (bool, optional): whether to output a triangular or quadmesh. Defaults to False.</p> References <p>https://danielsieger.com/blog/2021/05/03/generating-primitive-shapes.html</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>a torus</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.sphere_uv","title":"<code>sphere_uv(n_lat=30, n_long=50, center=Vec(0.0, 0.0, 0.0), radius=1.0)</code>","text":"<p>Generates a sphere using classical spherical uv-coordinates </p> <p>Parameters:</p> Name Type Description Default <code>n_lat</code> <code>int</code> <p>number of different latitudes for points. Defaults to 30.</p> <code>30</code> <code>n_long</code> <code>int</code> <p>number of different longitudes for points. Defaults to 50.</p> <code>50</code> <code>center</code> <code>Vec</code> <p>Center position of the sphere. Defaults to Vec(0.,0.,0.).</p> <code>Vec(0.0, 0.0, 0.0)</code> <code>radius</code> <code>float</code> <p>Radius of the sphere. Defaults to 1.</p> <code>1.0</code> References <p>https://danielsieger.com/blog/2021/03/27/generating-spheres.html</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the sphere</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.icosphere","title":"<code>icosphere(n_refine=3, center=Vec(0.0, 0.0, 0.0), radius=1.0)</code>","text":"<p>Generates an icosphere, that is a subdivision of the icosahedron</p> <p>Parameters:</p> Name Type Description Default <code>n_refine</code> <code>int</code> <p>number of subdivisions. Defaults to 3.</p> <code>3</code> <code>center</code> <code>Vec</code> <p>center of the sphere. Defaults to Vec(0.,0.,0.).</p> <code>Vec(0.0, 0.0, 0.0)</code> <code>radius</code> <code>float</code> <p>radius of the sphere. Defaults to 1..</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the sphere</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.shapes.sphere_fibonacci","title":"<code>sphere_fibonacci(n_pts, radius=1.0, build_surface=True)</code>","text":"<p>Generates a point cloud or a surface mesh using fibonacci sampling of a sphere.</p> <p>Parameters:</p> Name Type Description Default <code>n_pts</code> <code>int</code> <p>total number of vertices</p> required <code>radius</code> <code>float</code> <p>Radius of the sphere. Defaults to 1.</p> <code>1.0</code> <code>build_surface</code> <code>bool</code> <p>If specified to True, the function will also compute a triangulation of the vertices. This is obtained through a convex hull algorithm (since points lay on a convex shape, the convex hull and the Delaunay triangulation are equivalent). Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>SurfaceMesh</code> <p>[SurfaceMesh | PointCloud]: the generated mesh</p>"},{"location":"manipulating_data/procedural/#polyline-generation","title":"Polyline generation","text":""},{"location":"manipulating_data/procedural/#mouette.procedural.polylines.chain_of_vertices","title":"<code>chain_of_vertices(vertices, loop=False)</code>","text":"<p>Creates a polyline that links the provided vertices in order.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>ndarray</code> <p>vertex positions.</p> required <code>loop</code> <code>bool</code> <p>whether to link the last vertex with the first, creating a closed loop. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>description</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.polylines.vector_field","title":"<code>vector_field(origins, vectors, length_mult=1.0)</code>","text":"<p>Creates the representation of a vector field from an array of origin points and an array of vectors.</p> <p>Parameters:</p> Name Type Description Default <code>origins</code> <code>ndarray</code> <p>size (N,K) with N the number of points and K&lt;=3 the dimension. Origin of the vectors</p> required <code>vectors</code> <code>ndarray</code> <p>size (N,K) with N the number of points and K&lt;=3 the dimension. Coordinates of each vector.</p> required <code>length_mult</code> <code>float</code> <p>factor multiplied to each vector to modulate their length for vizualisation purposes. Defaults to 1.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the two arrays (origins and vectors) have a different shape</p> <code>Exception</code> <p>fails if one of the two arrays have dimension &gt; 3</p> <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the vector field represented as a polyline.</p>"},{"location":"manipulating_data/procedural/#transformations","title":"Transformations","text":""},{"location":"manipulating_data/procedural/#mouette.procedural.transformations.spherify_vertices","title":"<code>spherify_vertices(points, radius=0.01, n_subdiv=1)</code>","text":"<p>Transforms vertices of a point cloud as icospheres</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>PointCloud</code> <p>the input point cloud</p> required <code>radius</code> <code>float</code> <p>radius of each sphere. Defaults to 1e-2.</p> <code>0.01</code> <code>n_subdiv</code> <code>int</code> <p>number of subdivisions of the icospheres. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>SurfaceMesh</code> <p>SurfaceMesh</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.transformations.cylindrify_edges","title":"<code>cylindrify_edges(mesh, radius=0.05, N=50)</code>","text":"<p>Transforms edges of a polyline as cylinder surface</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>PolyLine</code> <p>the input mesh</p> required <code>radius</code> <code>float</code> <p>Radius of the output cylinders. Defaults to 5e-2.</p> <code>0.05</code> <code>N</code> <code>int</code> <p>Number of points inside each circle of the cylinders. Defaults to 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>SurfaceMesh</code> <p>SurfaceMesh</p>"},{"location":"manipulating_data/procedural/#mouette.procedural.dual.dual_mesh","title":"<code>dual_mesh(mesh, mode='barycenter')</code>","text":"<p>Computes the dual mesh of a mesh</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input surface</p> required <code>mode</code> <code>str</code> <p>which position</p> <code>'barycenter'</code> <p>Returns:</p> Type Description <code>SurfaceMesh</code> <p>SurfaceMesh</p>"},{"location":"manipulating_data/sampling/","title":"Point Sampling","text":""},{"location":"manipulating_data/sampling/#mouette.sampling.sample_AABB","title":"<code>sample_AABB(box, n_pts, mode='uniform', return_point_cloud=False)</code>","text":"<p>Sample a point cloud uniformly at random inside an axis-aligned bounding box. Works by sampling the unit cube and applying an affine transformation.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>AABB</code> <p>the domain of sampling</p> required <code>n_pts</code> <code>int</code> <p>number of points to sample. If mode is 'grid', the function may return a slightly smaller number of points (nearest perfect n-th root).</p> required <code>mode</code> <code>str</code> <p>sampling mode. 'uniform' or 'grid'. Uniform takes points at random, while 'grid' generates a grid of regularly spaced points.</p> <code>'uniform'</code> <code>return_point_cloud</code> <code>bool</code> <p>whether to compile the points in a PointCloud object or return the raw numpy array. Is ignored if the bounding box has dimension &gt;3. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>fails if the bounding box is empty.</p> <code>ValueError</code> <p>fails if the dimension of the box is &gt; 3 and return_point_cloud is set to True, so that no PointCloud object with dim &gt; 3 is created.</p> <p>Returns:</p> Type Description <p>PointCloud | np.ndarray: a sampled point cloud of <code>n_pts</code> points</p>"},{"location":"manipulating_data/sampling/#mouette.sampling.sample_ball","title":"<code>sample_ball(center, radius, n_pts, return_point_cloud=False)</code>","text":"<p>Samples points uniformly inside a 3D ball.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Vec</code> <p>center of the ball</p> required <code>radius</code> <code>float</code> <p>radius of the ball</p> required <code>n_pts</code> <code>int</code> <p>number of points to sample</p> required <code>return_point_cloud</code> <code>bool</code> <p>whether to compile the points in a PointCloud object or return the raw numpy array. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>PointCloud | np.ndarray: a sampled point cloud of <code>n_pts</code> points</p>"},{"location":"manipulating_data/sampling/#mouette.sampling.sample_polyline","title":"<code>sample_polyline(mesh, n_pts, return_point_cloud=False)</code>","text":"<p>Sample a point cloud uniformly at random from a polyline</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>PolyLine</code> <p>the input polyline</p> required <code>n_pts</code> <code>int</code> <p>number of points to sample</p> required <code>return_point_cloud</code> <code>bool</code> <p>whether to compile the points in a PointCloud object or return the raw numpy array. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>PointCloud | np.ndarray:  a sampled point cloud of <code>n_pts</code> points</p>"},{"location":"manipulating_data/sampling/#mouette.sampling.sample_sphere","title":"<code>sample_sphere(center, radius, n_pts, return_point_cloud=False)</code>","text":"<p>Samples points uniformly on the surface of a 3D sphere</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Vec</code> <p>center of the sphere</p> required <code>radius</code> <code>float</code> <p>radius of the spheres</p> required <code>n_pts</code> <code>int</code> <p>number of points to sample</p> required <code>return_point_cloud</code> <code>bool</code> <p>whether to compile the points in a PointCloud object or return the raw numpy array. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>PointCloud | np.ndarray: a sampled point cloud of <code>n_pts</code> points</p>"},{"location":"manipulating_data/sampling/#mouette.sampling.sample_surface","title":"<code>sample_surface(mesh, n_pts, return_point_cloud=False, return_normals=False)</code>","text":"<p>Sample a point cloud uniformly at random from a surface mesh</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <code>n_pts</code> <code>int</code> <p>number of points to sample</p> required <code>return_point_cloud</code> <code>bool</code> <p>whether to compile the points in a PointCloud object or return the raw numpy array. Defaults to False.</p> <code>False</code> <code>return_normals</code> <code>bool</code> <p>wether to assign the normal of the faces to sampled points. Only has effect if return_point_cloud is set to True. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>the mesh is not a triangular mesh</p> <p>Returns:</p> Type Description <p>PointCloud | np.ndarray: a sampled point cloud of <code>n_pts</code> points</p> <p>np.ndarray : the associated normals (if sample_normals was set to True)</p>"},{"location":"manipulating_data/sampling/#mouette.sampling.sample_surface_barycentric","title":"<code>sample_surface_barycentric(mesh, n_pts)</code>","text":"<p>Sample a point cloud uniformly at random from a surface mesh, but computes face ids and barycentric coordinates instead of point coordinates.</p> <p>This function returns two arrays F and B such that: F[i] = f and B[i] = a,b,c means that the i-th point is defined as apA + bpB + c*pC where (pA,pB,pC) are the vertices of face f.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>SurfaceMesh</code> <p>input mesh</p> required <code>n_pts</code> <code>int</code> <p>number of points to sample</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>the mesh is not a triangular mesh</p> <p>Returns:</p> Type Description <p>np.ndarray: the index of the face in which each point belong</p> <p>np.ndarray: the associated barycentric coordinates of the vertex</p>"},{"location":"manipulating_data/subdivision/","title":"Mesh Subdivision","text":"<p>Due to the connectivity data attached to the meshes data structures, subdividing meshes by hand is unsafe and can lead to faulty results. To correctly apply subdivisions, one needs to first convert back the mesh to a <code>RawMeshData</code>, apply the combinatorial functions, and rebuild a correct mesh. This is handled by the <code>SurfaceSubdivision</code> and the <code>VolumeSubdivision</code> classes, which are designed to be used in a <code>with</code> block:</p> <pre><code>import mouette as M\n\nsurface = M.mesh.load(\"/path/to/my/mesh.obj\")\n\n# At the start of the with block, the mesh is transformed into a RawMeshData and its connectivity is disabled\nwith M.mesh.SurfaceSubdivision(surface) as editor:\n    # Call here the subdivision functions\n    editor.subdivide_triangles_3quads()\n    editor.triangulate()\n# When exiting the 'with' block, the mesh is transformed back into a SurfaceMesh\n# and its connectivity is regenerated\nM.mesh.save(surface, \"path/to/my/new/mesh.obj\")\n</code></pre>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.SurfaceSubdivision","title":"<code>SurfaceSubdivision(mesh, verbose=False)</code>","text":"<p>               Bases: <code>Logger</code></p>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.SurfaceSubdivision.loop_subdivision","title":"<code>loop_subdivision(n=1)</code>","text":"<p>Subdivides triangles of a mesh in 4 triangles by splitting along middle of edges.     If the mesh is not triangulated, will triangulate the mesh first.</p> References <p>https://en.wikipedia.org/wiki/Loop_subdivision_surface</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of times the subdivision is applied. Defaults to 1.</p> <code>1</code>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.SurfaceSubdivision.split_face_as_fan","title":"<code>split_face_as_fan(face_id)</code>","text":"<p>Adds a vertex at the barycenter of face 'face_id' and create a fan of triangles that replaces the face</p> <p>Parameters:</p> Name Type Description Default <code>face_id</code> <code>int</code> <p>the face to split</p> required"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.SurfaceSubdivision.subdivide_triangles_3quads","title":"<code>subdivide_triangles_3quads()</code>","text":"<p>Subdivides triangles of a mesh in 3 quads by adding a point at the barycenter and three middles of edges. If the mesh is not triangulated, will triangulate the mesh first.</p>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.SurfaceSubdivision.subdivide_triangles_6","title":"<code>subdivide_triangles_6(repeat=1)</code>","text":"<p>Subdivides triangles of a mesh in 6 triangles by adding a point at the barycenter and three middles of edges.     If the mesh is not triangulated, will triangulate the mesh first.</p> <pre><code>Same operation as subdividing into 3 quads and then splitting the quads along the corner-barycenter diagonal.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>repeat</code> <code>int</code> <p>number of successive subdivisions. Eventual first triangulation does not count. Defaults to 1.</p> <code>1</code>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.SurfaceSubdivision.triangulate","title":"<code>triangulate()</code>","text":"<p>Triangulates all faces of a mesh. Calls triangulate_face on every faces.</p>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.SurfaceSubdivision.triangulate_face","title":"<code>triangulate_face(face_id)</code>","text":"<p>Triangulates the face \"face_id\"</p> <p>Parameters:</p> Name Type Description Default <code>face_id</code> <code>int</code> <p>the face to triangulate</p> required"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.VolumeSubdivision","title":"<code>VolumeSubdivision(mesh, verbose=False)</code>","text":"<p>               Bases: <code>Logger</code></p>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.VolumeSubdivision.split_cell_as_fan","title":"<code>split_cell_as_fan(cell_id)</code>","text":"<p>Adds a vertex at the barycenter of cell 'cell_id' and create a fan of tetrahedra that replaces the cell. If the cell 'cell_id' is not a tetrahedron, does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>VolumeMesh</code> <p>the input mesh</p> required <code>cell_id</code> <code>int</code> <p>the (tetrahedral) cell to split</p> required <p>Returns:</p> Type Description <code>VolumeMesh</code> <p>the modified input mesh</p>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.VolumeSubdivision.split_tet_from_face_center","title":"<code>split_tet_from_face_center(face_id)</code>","text":"<p>Split the triangle <code>face_id</code> into three triangles by adding a point at its barycenter, and split adjacent tetrahedra accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>face_id</code> <code>int</code> <p>index of the face to split</p> required"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.split_edge","title":"<code>split_edge(polyline, edge_ind)</code>","text":"<p>Split an edge of a polyline in half by adding a new vertex</p> Note <p>Polylines do not need a specific subdivision class to be used in a <code>with</code> block since their connectivity is simpler.  Connectivity is cleared after processing.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>PolyLine</code> <p>the input polyline</p> required <code>edge_ind</code> <code>int</code> <p>index of the edge to split</p> required <p>Returns:</p> Name Type Description <code>PolyLine</code> <code>PolyLine</code> <p>the processed Polyline</p>"},{"location":"manipulating_data/subdivision/#mouette.mesh.subdivision.split_double_boundary_edges_triangles","title":"<code>split_double_boundary_edges_triangles(mesh)</code>","text":"<p>A triangle with double edge on the boundary can occur on the border in a case like :</p> <pre><code>    /\\ \n___/__\\___\n</code></pre> <p>This function detects every occurrences of such a configuration and split the problematic triangle in three by adding a new vertex in the middle. Uses the SurfaceSubdivision class.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the mesh (modified in place)</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Isolated vertex</p> <p>Returns:</p> Name Type Description <code>SurfaceMesh</code> <code>SurfaceMesh</code> <p>the modified input mesh</p>"},{"location":"manipulating_data/transforms/","title":"Rigid Transformations","text":""},{"location":"manipulating_data/transforms/#mouette.geometry.transform.fit_into_unit_cube","title":"<code>fit_into_unit_cube(mesh)</code>","text":"<p>Applies translation and global scaling for the mesh to fit inside a cube [0;1]^3</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh. Can be any mesh data structure</p> required Note <p>Alias for <code>transform.normalize(mesh, center_at_zero=False)</code></p> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>the scaled and translated mesh</p>"},{"location":"manipulating_data/transforms/#mouette.geometry.transform.flatten","title":"<code>flatten(mesh, dim=None)</code>","text":"<p>Snaps to 0 one dimension to retrieve a flat 2D mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>input mesh</p> required <code>dim</code> <code>int</code> <p>The dimension to flatten. If None, the function chooses the dimension which has the smallest variance.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>the modified input mesh</p>"},{"location":"manipulating_data/transforms/#mouette.geometry.transform.normalize","title":"<code>normalize(mesh, center_at_zero=True)</code>","text":"<p>Applies translation and global scaling so that the barycenter of the mesh becomes the origin and the mesh is contained in [-1,1]^3</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh</p> required <code>center_at_zero</code> <code>bool</code> <p>if set to True, will normalize in the cube [-1,1]^3. Otherwise, will normalize in [0,1]^3. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>the scaled and translated mesh</p>"},{"location":"manipulating_data/transforms/#mouette.geometry.transform.rotate","title":"<code>rotate(mesh, rot, orig=None)</code>","text":"<p>Rotates all vertices of the mesh by a given rotation around a given origin.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh. Can be any mesh data structure</p> required <code>rot</code> <code>Rotation | list</code> <p>The rotation, given as an object or 3 Euler angles</p> required <code>orig</code> <code>Vec</code> <p>The origin of the rotation. If not provided, the function rotates around (0,0,0). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>description</p>"},{"location":"manipulating_data/transforms/#mouette.geometry.transform.scale","title":"<code>scale(mesh, factor, orig=None)</code>","text":"<p>Scales the mesh by a given factor around a given origin (fixed point)</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh. Can be any mesh data structure</p> required <code>factor</code> <code>float</code> <p>scale factor. If its magnitude is &lt; 1e-8, will print a warning.</p> required <code>orig</code> <code>Vec</code> <p>Fixed point of the scaling. If not provided, it is set at (0,0,0). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>the scaled input mesh.</p>"},{"location":"manipulating_data/transforms/#mouette.geometry.transform.scale_xyz","title":"<code>scale_xyz(mesh, fx=1.0, fy=1.0, fz=1.0, orig=None)</code>","text":"<p>Scales the mesh independently along three axes. If any factor as a magnitude &lt; 1e-8, will print a warning.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh. Can be any mesh data structure</p> required <code>fx</code> <code>float</code> <p>Scale factor along x. Defaults to 1.</p> <code>1.0</code> <code>fy</code> <code>float</code> <p>Scale factor along y. Defaults to 1.</p> <code>1.0</code> <code>fz</code> <code>float</code> <p>Scale factor along z. Defaults to 1.</p> <code>1.0</code> <code>orig</code> <code>Vec</code> <p>Fixed point of the scaling. If not provided, it is set at (0,0,0). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>the scaled mesh.</p>"},{"location":"manipulating_data/transforms/#mouette.geometry.transform.translate","title":"<code>translate(mesh, tr)</code>","text":"<p>Translates all vertices of the mesh by a fixed vector</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh. Can be any mesh data structure</p> required <code>tr</code> <code>Vec</code> <p>the translation vector</p> required <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>the translated mesh</p>"},{"location":"manipulating_data/transforms/#mouette.geometry.transform.translate_to_origin","title":"<code>translate_to_origin(mesh)</code>","text":"<p>Translates all vertices of the mesh so that its barycenter is at origin (0., 0., 0.)</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>the input mesh</p> required <p>Returns:</p> Name Type Description <code>Mesh</code> <code>Mesh</code> <p>the translated mesh</p>"},{"location":"optimization/","title":"Numerical Optimization","text":"<ul> <li> <p>Eigensolvers </p> </li> <li> <p>Newton's method </p> </li> <li> <p>Levenberg-Marquardt </p> </li> </ul>"},{"location":"optimization/eigensolve/","title":"Eigensolvers","text":""},{"location":"optimization/eigensolve/#mouette.optimize.eigensolve.inverse_power_method","title":"<code>inverse_power_method(A, m=0.0, B=None, maxiter=100, tol=1e-10)</code>","text":"<p>Implementation of the inverse power method (or inverse iteration) scheme to find an eigenvector associated with an eigenvalue of A that is close to 'm'. In other words, this function computes x such that : Ax = \u03bbBx where \u03bb is an eigenvalue of A that minimizes |\u03bb-m|.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>csc_matrix</code> <p>the matrix</p> required <code>mu</code> <code>float</code> <p>the approximate eigenvalue. Will compute an eigenvector for the eigenvalue \u03bb that minimizes its distance to mu. Defaults to zero.</p> required <code>B</code> <code>csc_matrix</code> <p>metrics matrix for generalized eigenvectors computation. If not specified, will be the identity matrix. Defaults to None.</p> <code>None</code> <code>maxiter</code> <code>int</code> <p>maximal number of internal iteration. Defaults to 100.</p> <code>100</code> <code>tol</code> <code>float</code> <p>early stopping criterion. Will stop the iteration if |x_{n+1} - x_n| &lt; tol. Defaults to 1e-6.</p> <code>1e-10</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: a unit norm eiven vector associated with an eigenvalue that is close to 'mu'</p>"},{"location":"optimization/eigensolve/#mouette.optimize.eigensolve.rayleigh_quotient_iteration","title":"<code>rayleigh_quotient_iteration(A, m=0.0, B=None, x0=None, maxiter=100, tol=1e-10)</code>","text":"<p>Performs Rayleigh quotient iteration on matrix A to find an eigenvector of A whose eigenvalue is near 'm'.  Similar to the inverse power method, except that the approximated eigenvalue is computed as the Rayleigh quotient, which converges faster for symmetric matrices.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>csc_matrix</code> <p>the matrix</p> required <code>m</code> <code>float</code> <p>the approximate eigenvalue. Will compute an eigenvector for the eigenvalue \u03bb that minimizes its distance to m. Defaults to zero.</p> <code>0.0</code> <code>B</code> <code>csc_matrix</code> <p>metrics matrix for generalized eigenvectors computation. If not specified, will be the identity matrix. Defaults to None.</p> <code>None</code> <code>x0</code> <code>ndarray</code> <p>Initial guess for the eigenvector. If not provided, will be taken as a random vector with normalized values. Defaults to None.</p> <code>None</code> <code>maxiter</code> <code>int</code> <p>maximal number of internal iteration. Defaults to 100.</p> <code>100</code> <code>tol</code> <code>float</code> <p>early stopping criterion. Will stop the iteration if |x_{n+1} - x_n| &lt; tol. Defaults to 1e-6.</p> <code>1e-10</code> References <p>https://en.wikipedia.org/wiki/Rayleigh_quotient_iteration</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An eigenvector of A associated with eigenvalue \u03bb that is closest to m.</p>"},{"location":"optimization/levenberg_marquardt/","title":"Levenberg-Marquardt","text":"<p>Given a function \\(F : \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\) of class \\(\\mathcal{C}^1\\), the Levenberg-Marquardt optimizer iteratively solves:</p> \\[ \\min_{x \\in \\mathbb{R}^n} \\frac{1}{2} ||F(x)||^2\\]"},{"location":"optimization/levenberg_marquardt/#principle","title":"Principle","text":"<p>Let \\(x_k\\) be the variable vector at iteration \\(k\\).  Define \\(m_\\lambda^k : \\mathbb{R}^n \\rightarrow \\mathbb{R}\\) by </p> \\[\\begin{align} m_\\lambda^k(x) &amp;= \\frac{1}{2}|| F_k + J_k (x - x_k) ||^2 + \\frac{\\lambda}{2} || x - x_k||^2 \\\\ &amp;= \\frac{1}{2}|| F_k + (J_k + \\lambda I) (x - x_k) ||^2 \\end{align} \\] <p>where \\(F_k = F(x_k)\\) is the value of the function at point \\(x_k\\) and \\(J_k = J(x_k)\\) is the value of its Jacobian matrix at point \\(x_k\\).</p> <p>Set \\(x_{k+1} = \\text{argmin}_x m_\\lambda^k(x)\\) for some \\(\\lambda = \\lambda_k \\in \\mathbb{R}^+\\)</p> <p>And iterate until convergence.</p>"},{"location":"optimization/levenberg_marquardt/#example","title":"Example","text":"<pre><code>import mouette as M\nimport numpy as np\nimport scipy.sparse as sp\n\ndef function_to_optimize(x, a, b):\n    # Rosenbrock function and gradient\n    f = np.array([(a-x[0])**2 + b*(x[1] - x[0]**2)**2])\n    J = sp.csr_matrix([2*(x[0]-a) - 4*b*x[0]*(x[1]-x[0]*x[0]),  2*b*(x[1]-x[0]*x[0])]).reshape((1,2))\n    return f,J\n\noptimizer = M.optimize.LevenbergMarquardt()\n\n# adjust hyperparameters from the HP attribute\noptimizer.HP.ENERGY_MIN = 1E-10\noptimizer.HP.MIN_GRAD_NORM = 0. \n\n# Register the function to optimize\noptimizer.register_function(lambda x : function_to_optimize(x, 1., 10.), name=\"Rosenbrock\")\noptimizer.run(x_init=np.random.random((2,))) # run the optimization starting from a random position\n\nprint(\"Local minimum found:\" , optimizer.X)\nprint(\"Expected minimum :\", [A,A])\n</code></pre>"},{"location":"optimization/levenberg_marquardt/#implementation","title":"Implementation","text":""},{"location":"optimization/levenberg_marquardt/#mouette.optimize.levenberg_marquardt.LMParameters","title":"<code>LMParameters(N_ITER_MAX=1000, ENERGY_MIN=1e-07, MIN_STEP_NORM=1e-05, MIN_GRAD_NORM=1e-05, MIN_DELTA_E=1e-05, MU_MAX=100000000.0, MU_MIN=1e-08, alpha=0.5, beta=2.0)</code>  <code>dataclass</code>","text":"<p>Hyper parameters for the Levenberg-Marquardt algorithm</p>"},{"location":"optimization/levenberg_marquardt/#mouette.optimize.levenberg_marquardt.LevenbergMarquardt","title":"<code>LevenbergMarquardt(HP=LMParameters(), verbose=LMVerboseOptions(), **kwargs)</code>","text":"<p>               Bases: <code>Logger</code></p> <p>Levenberg-Marquardt algorithm for non-linear least-square minimization.</p> References <p>[1] https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm</p> <p>[2] Constrained Levenberg-Marquardt Method with global complexity bounds, Marumo et al.</p> Example <p>https://github.com/GCoiffier/mouette/blob/main/examples/optimization/levenberg_marquardt_example.py</p>"},{"location":"optimization/levenberg_marquardt/#mouette.optimize.levenberg_marquardt.LevenbergMarquardt.optimize","title":"<code>optimize(x_init)</code>","text":"<p>Alias of the 'run' method.</p> <p>Parameters:</p> Name Type Description Default <code>x_init</code> <code>ndarray</code> <p>initial values for the variables.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>final value of the energy</p>"},{"location":"optimization/levenberg_marquardt/#mouette.optimize.levenberg_marquardt.LevenbergMarquardt.register_constraints","title":"<code>register_constraints(A, l=None, u=None)</code>","text":"<p>Adds linear constraints to the optimization problem :</p> <p>min_X ||F(X)||\u00b2 s.t.  l &lt;= AX &lt;= u</p> <p>Parameters:</p> Name Type Description Default <code>cstMat</code> <code>spmatrix</code> <p>constraint matrix, either dense or sparse</p> required <code>cstL</code> <code>ndarray</code> <p>vector l. Defaults to None.</p> required <code>cstR</code> <code>ndarray</code> <p>vector u. Defaults to None.</p> required"},{"location":"optimization/levenberg_marquardt/#mouette.optimize.levenberg_marquardt.LevenbergMarquardt.register_function","title":"<code>register_function(fun, fun_noJ=None, weight=1.0, name=None)</code>","text":"<p>Adds a function to minimize.</p> <p>Parameters:</p> Name Type Description Default <code>fun</code> <code>python callable</code> <p>A function taking a single argument X (np.array) returning a vector of values F and a (sparse or dense) jacobian matrix J</p> required <code>fun_noJ</code> <code>python callable</code> <p>The same function that avoids the computation of the jacobian for speed purposes. If not provided, will use the function provided above and ignore the jacobian.</p> <code>None</code> <code>weight</code> <code>float</code> <p>real weight to be applied to the function. Defaults to 1..</p> <code>1.0</code> <code>name</code> <code>str</code> <p>Name of the function in the logs. If not specified, the function will be given a default name.</p> <code>None</code>"},{"location":"optimization/levenberg_marquardt/#mouette.optimize.levenberg_marquardt.LevenbergMarquardt.run","title":"<code>run(x_init)</code>","text":"<p>Runs the optimizer</p> <p>Parameters:</p> Name Type Description Default <code>x_init</code> <code>ndarray</code> <p>initial values for the variables.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>final value of the energy</p>"},{"location":"optimization/newton/","title":"Newton","text":""},{"location":"optimization/newton/#mouette.optimize.newton.Newton","title":"<code>Newton(HP=NewtonParameters(), verbose=NewtonVerboseOptions(), **kwargs)</code>","text":"<p>               Bases: <code>Logger</code></p> <p>Newton's algorithm to find the minimum of a function knowing its gradient and hessian.</p> References <p>[1] https://won-j.github.io/M1399_000200-2021fall/lectures/22-newton/newton_constr.html</p>"},{"location":"optimization/newton/#mouette.optimize.newton.Newton.optimize","title":"<code>optimize(x_init)</code>","text":"<p>Alias of the 'run' method.</p> <p>Parameters:</p> Name Type Description Default <code>x_init</code> <code>ndarray</code> <p>initial values for the variables.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>final value of the energy</p>"},{"location":"optimization/newton/#mouette.optimize.newton.Newton.register_constraints","title":"<code>register_constraints(A, l=None, u=None)</code>","text":"<p>Adds linear constraints to the optimization problem :</p> <p>min_X  F(X) s.t.  l &lt;= AX &lt;= u</p> <p>Parameters:</p> Name Type Description Default <code>cstMat</code> <code>spmatrix</code> <p>constraint matrix, either dense or sparse</p> required <code>cstL</code> <code>ndarray</code> <p>vector l. Defaults to None.</p> required <code>cstR</code> <code>ndarray</code> <p>vector u. Defaults to None.</p> required"},{"location":"optimization/newton/#mouette.optimize.newton.Newton.register_function","title":"<code>register_function(fun, fun_noG=None)</code>","text":"<p>Adds a function to minimize.</p> <p>Parameters:</p> Name Type Description Default <code>fun</code> <code>python callable</code> <p>A function taking a single argument X (np.array) returning a real value F, a gradient G and a hessian matrix H</p> required <code>fun_noG</code> <code>python callable</code> <p>The same function that avoids the computation of the gradient and the hessian for speed purposes. If not provided, will use the function provided above and ignore the other arguments.</p> <code>None</code>"},{"location":"optimization/newton/#mouette.optimize.newton.Newton.run","title":"<code>run(x_init)</code>","text":"<p>Runs the optimizer</p> <p>Parameters:</p> Name Type Description Default <code>x_init</code> <code>ndarray</code> <p>initial values for the variables.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>final value of the energy</p>"},{"location":"optimization/newton/#mouette.optimize.newton.NewtonParameters","title":"<code>NewtonParameters(N_ITER_MAX=1000, MIN_STEP_NORM=1e-06, MIN_DELTA_F=1e-08, MIN_GRAD_NORM=1e-08, alpha_init=1.0, c1=0.0001, rho=0.5)</code>  <code>dataclass</code>","text":"<p>Hyper parameters for Newton's algorithm</p>"},{"location":"utilities/AABB/","title":"Axis-Aligned Bounding Box","text":""},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB","title":"<code>AABB(p_min, p_max)</code>","text":"<p>Axis Aligned Bounding Box in n dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>p_min</code> <code>Iterable</code> <p>minimal values for each dimension</p> required <code>p_max</code> <code>Iterable</code> <p>maximal values for each dimension</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>fails if p_min and p_max have different sizes (inconsistent dimension)</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.center","title":"<code>center</code>  <code>property</code>","text":"<p>Coordinates of the center point</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>center point</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.dim","title":"<code>dim</code>  <code>property</code>","text":"<p>Dimension of the axis-aligned bounding box</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>dimension</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.maxi","title":"<code>maxi</code>  <code>property</code>","text":"<p>Maximum coordinates of any point inside the box.  The box is an axis-aligned hexahedron which opposite corners are mini and maxi</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>maximum coordinates</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.mini","title":"<code>mini</code>  <code>property</code>","text":"<p>Minimum coordinates of any point inside the box The box is an axis-aligned hexahedron which opposite corners are mini and maxi</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>minimum coordinates</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.span","title":"<code>span</code>  <code>property</code>","text":"<p>Dimensions of the box</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>dimensions of the box</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.contains_point","title":"<code>contains_point(pt)</code>","text":"<p>Point - bounding box intersection predicate. If the point is on the boundary of the box, the convention is as follows: inclusive if the point touches the min coordinates, exclusive for the max coordinates</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Vec</code> <p>a query position</p> required <p>Raises:</p> Type Description <code>IncompatibleDimensionError</code> <p>fails if the point has a different dimension than the bounding box.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the point 'pt' is inside the bounding box.</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.distance","title":"<code>distance(pt, which='l2')</code>","text":"<p>Computes the distance from a point to the bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Vec</code> <p>coordinates of the point</p> required <code>which</code> <code>str</code> <p>which distance to consider. Choices are 'l2', 'l1' or 'linf'. Defaults to \"l2\".</p> <code>'l2'</code> <p>Raises:</p> Type Description <code>IncompatibleDimensionError</code> <p>fails if the point has a different dimension than the bounding box.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the distance from the point to the bounding box</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.do_intersect","title":"<code>do_intersect(b1, b2)</code>  <code>staticmethod</code>","text":"<p>Intersection test between two bounding boxes</p> <p>Parameters:</p> Name Type Description Default <code>b1</code> <code>AABB</code> <p>first bounding box</p> required <code>b2</code> <code>AABB</code> <p>second bounding box</p> required <p>Raises:</p> Type Description <code>IncompatibleDimensionError</code> <p>fails if b1 and b2 have different dimensions</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the two BB intersect</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.infinite","title":"<code>infinite(dim)</code>  <code>classmethod</code>","text":"<p>Computes a bounding box with bounds at infinity, containing the whole space R^n</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>dimension of the BB to build</p> required <p>Returns:</p> Name Type Description <code>AABB</code> <code>AABB</code> <p>A bounding box containing all of R^n</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.intersection","title":"<code>intersection(b1, b2)</code>  <code>staticmethod</code>","text":"<p>Computes the intersection bounding box of two bounding boxes</p> <p>Parameters:</p> Name Type Description Default <code>b1</code> <code>AABB</code> <p>first bounding box</p> required <code>b2</code> <code>AABB</code> <p>second bounding box</p> required <p>Raises:</p> Type Description <code>IncompatibleDimensionError</code> <p>fails if b1 and b2 have different dimensions</p> <p>Returns:</p> Name Type Description <code>AABB</code> <code>AABB</code> <p>a bounding box representing the intersection (may be empty).</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.is_empty","title":"<code>is_empty()</code>","text":"<p>Tests if the bounding box encloses an empty domain</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the bounding box is empty</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.of_mesh","title":"<code>of_mesh(mesh, padding=0.0)</code>  <code>classmethod</code>","text":"<p>Computes the 3D bounding box of all vertices of a mesh</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>input mesh. Can be of any type (only the 'vertices' container is accessed)</p> required <code>padding</code> <code>float</code> <p>slack to be added between the mesh and the box. Defaults to 0 for a tight bounding box.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>AABB</code> <code>AABB</code> <p>3D bounding box of the vertices of the mesh</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.of_points","title":"<code>of_points(points, padding=0.0)</code>  <code>classmethod</code>","text":"<p>Computes the bounding box of a set of nD points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>input points</p> required <code>padding</code> <code>float</code> <p>slack to be added between the mesh and the box. Defaults to 0 for a tight bounding box.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>AABB</code> <code>AABB</code> <p>nD bounding box of the points</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.pad","title":"<code>pad(pad)</code>","text":"<p>Enlarges the bounding box by adding <code>pad</code> on each dimension on each side. Does nothing if the padding values are negative.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>float | iterable</code> <p>Additional dimensions to be added. If a float is provided, will assume that padding is the same for each dimensions. If an array is provided, its size should match the dimension of the box. Values are clamped to be &gt;=0.</p> required"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.project","title":"<code>project(pt)</code>","text":"<p>Computes the closest point from point 'pt' in the bounding box in Euclidean distance</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Vec</code> <p>the point to project</p> required <p>Raises:</p> Type Description <code>IncompatibleDimensionError</code> <p>fails if the point has a different dimension than the bounding box.</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>the projected point</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.union","title":"<code>union(b1, b2)</code>  <code>staticmethod</code>","text":"<p>Computes the union bounding box of two bounding boxes</p> <p>Parameters:</p> Name Type Description Default <code>b1</code> <code>AABB</code> <p>first bounding box</p> required <code>b2</code> <code>AABB</code> <p>second bounding box</p> required <p>Raises:</p> Type Description <code>IncompatibleDimensionError</code> <p>fails if b1 and b2 have different dimensions</p> <p>Returns:</p> Name Type Description <code>AABB</code> <code>AABB</code> <p>a bounding box representing the union</p>"},{"location":"utilities/AABB/#mouette.geometry.aabb.AABB.unit_cube","title":"<code>unit_cube(dim, centered=False)</code>  <code>classmethod</code>","text":"<p>Computes the unit bounding box [0,1]^n or [-0.5, 0.5]^n</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>dimension of the BB to build</p> required <code>centered</code> <code>bool</code> <p>whether to generate [0,1]^n (False) or [-0.5;0.5]^n (True). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>AABB</code> <code>AABB</code> <p>a hypercube of side length 1</p>"},{"location":"utilities/priority_queue/","title":"Priority Queue","text":""},{"location":"utilities/priority_queue/#mouette.utils.priority_queue.PriorityItem","title":"<code>PriorityItem(x, priority)</code>  <code>dataclass</code>","text":"<p>Dataclass representing an item inside the priority queue. An item is a pair element/priority.</p>"},{"location":"utilities/priority_queue/#mouette.utils.priority_queue.PriorityQueue","title":"<code>PriorityQueue()</code>","text":"<p>Implementation of a priority queue using a heap from the heapq package.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>list</code> <p>the list representing the queue</p> <p>Initializes an empty queue.</p>"},{"location":"utilities/priority_queue/#mouette.utils.priority_queue.PriorityQueue.front","title":"<code>front</code>  <code>property</code>","text":"<p>The first element of the queue. Is accessed but not removed from the queue</p> <p>Returns:</p> Name Type Description <code>PriorityItem</code> <code>PriorityItem</code> <p>The first element of the queue</p>"},{"location":"utilities/priority_queue/#mouette.utils.priority_queue.PriorityQueue.empty","title":"<code>empty()</code>","text":"<p>Tests if the queue contains any element.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the queue is empty</p>"},{"location":"utilities/priority_queue/#mouette.utils.priority_queue.PriorityQueue.get","title":"<code>get()</code>","text":"<p>Returns the first element of the queue. The element is removed from the queue.</p> <p>Returns:</p> Name Type Description <code>PriorityItem</code> <code>PriorityItem</code> <p>The first element of the queue</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>if the queue is empty</p>"},{"location":"utilities/priority_queue/#mouette.utils.priority_queue.PriorityQueue.pop","title":"<code>pop()</code>","text":"<p>Returns the first element of the queue. Same method as <code>get</code>.</p> <p>Returns:</p> Name Type Description <code>PriorityItem</code> <code>PriorityItem</code> <p>The first element of the queue</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>if the queue is empty</p>"},{"location":"utilities/priority_queue/#mouette.utils.priority_queue.PriorityQueue.push","title":"<code>push(x, w)</code>","text":"<p>Inserts an element inside the queue.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Element to insert in the queue</p> required <code>w</code> <code>float</code> <p>Priority of the element.</p> required"},{"location":"utilities/spherical_harmonics/","title":"L4 Spherical Harmonics","text":"<p>Spherical Harmonics are a basis of functions over which any function defined on the sphere can be decomposed. In mouette, we make use of the nine frequency L=4 harmonics to represent orthogonal frame fields in 3D. The <code>geometry.SphericalHarmonics</code> utility allow to manipulate such objects.</p> <p> </p>  Spherical harmonics from frequency L=1 to L=4 (from Wikipedia)  <p>Attributes:</p> Name Type Description <code>EYE</code> <code>L4_SH</code> <p>Coefficient of the identity frame in L4_SH</p> <code>LX</code> <code>L4_Operator</code> <p>Angular momentum operator for spherical harmonics representation, x-axis</p> <code>LY</code> <code>L4_Operator</code> <p>Angular momentum operator for spherical harmonics representation, y-axis</p> <code>LZ</code> <code>L4_Operator</code> <p>Angular momentum operator for spherical harmonics representation, z-axis</p> <code>Rxpi4</code> <code>L4_Operator</code> <p>rotation of angle pi/4 around axis x</p> <code>Rypi4</code> <code>L4_Operator</code> <p>rotation of angle pi/4 around axis y</p> <code>Rzpi4</code> <code>L4_Operator</code> <p>rotation of angle pi/4 around axis z</p> <code>Rxzpi4</code> <code>L4_Operator</code> <p>composition Rzpi4 * Rxpi4</p> <code>Rxpi2</code> <code>L4_Operator</code> <p>rotation of angle pi/2 around axis x</p> <code>Rypi2</code> <code>L4_Operator</code> <p>rotation of angle pi/2 around axis y</p> <code>Rzpi2</code> <code>L4_Operator</code> <p>rotation of angle pi/2 around axis z</p> References <p>Algebraic Representations for Volumetric Frame Fields, Palmer et al. (Supplementary materials)</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.L4_Operator","title":"<code>L4_Operator = Annotated[np.ndarray, (9, 9)]</code>  <code>module-attribute</code>","text":"<p>Type annotation for linear operators acting on L4_SH (i.e. 9x9 matrices)</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.L4_SH","title":"<code>L4_SH = Annotated[np.ndarray, 9]</code>  <code>module-attribute</code>","text":"<p>Type annotation for linear combinations of L4 Spherical Harmonics.  Orthogonal frames are represented by 9 coefficients in the L4 band of the spherical harmonics basis.  In practice, L4_SH is a size 9 numpy array.</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.RX","title":"<code>RX(a)</code>","text":"<p>The L4 operator representing a rotation around x-axis of angle a</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>angle</p> required <p>Returns:</p> Name Type Description <code>L4_Operator</code> <code>L4_Operator</code> <p>9x9 matrix</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.RY","title":"<code>RY(a)</code>","text":"<p>The L4 operator representing a rotation around y-axis of angle a</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>angle</p> required <p>Returns:</p> Name Type Description <code>L4_Operator</code> <code>L4_Operator</code> <p>9x9 matrix</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.RZ","title":"<code>RZ(a)</code>","text":"<p>The L4 operator representing a rotation around z-axis of angle a</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>angle</p> required <p>Returns:</p> Name Type Description <code>L4_Operator</code> <code>L4_Operator</code> <p>9x9 matrix</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.from_frame","title":"<code>from_frame(frame)</code>","text":"<p>Given a rotation as a scipy.Rotation object, computes the corresponding frame coefficients in L4_SH basis.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>Rotation</code> <p>a scipy rotation.</p> required <p>Returns:</p> Name Type Description <code>L4_SH</code> <code>L4_SH</code> <p>corresponding coefficients</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.from_vec3","title":"<code>from_vec3(v)</code>","text":"<p>Given a rotation in angle-axis form, computes the corresponding frame coefficients in L4_SH basis.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Vec</code> <p>a rotation axis vector where norm(v) represents the angle of rotation.</p> required <p>Returns:</p> Name Type Description <code>L4_SH</code> <code>L4_SH</code> <p>corresponding coefficients</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.orthogonality_energy","title":"<code>orthogonality_energy(sh)</code>","text":"<p>Computes an energy that is 0 if and only if the given spherical harmonics has octahedral symetry (ie represents an orthogonal frame) The energy is quadratic in terms of the harmonic coefficients</p> <p>Parameters:</p> Name Type Description Default <code>sh</code> <code>ndarray</code> <p>a spherical harmonics (9 coefficients)</p> required <p>Returns:</p> Type Description <code>float</code> <p>the computed energy</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.project_to_frame","title":"<code>project_to_frame(sh, stop_threshold=1e-08, max_iter=1000, nrml_cstr=None)</code>","text":"<p>Given the coefficients in the spherical harmonic basis, finds the frames that correspond the most. Also recomputes spherical harmonics coefficients to a perfect match. Uses the Cayleigh transform to approximate the 9D rotation.</p> <p>Parameters:</p> Name Type Description Default <code>sh</code> <code>Vec</code> <p>the 9 coefficients representing the frame in spherical harmonics basis</p> required <code>stop_threshold (float,optional) </code> <p>Stoping criterion on the norm of the residual. Defaults to 1e-8.</p> required <code>max_iter</code> <code>int</code> <p>Maximum number of gradient steps. Defaults to 100.</p> <code>1000</code> <code>nrml_cstr (Vec) </code> <p>a 3 dimensionnal normal direction, to constraint the projection to only be around an axis. Defaults to None.</p> required <p>Returns:</p> Type Description <p>frame (scipy.spatial.transform.Rotation) : the obtained frame</p> <p>a (L4_SH) : the projected and updated spherical harmonics coefficients</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.project_to_frame_grad","title":"<code>project_to_frame_grad(sh, lr=0.1, grad_threshold=0.0001, dot_threshold=1e-06, max_iter=1000)</code>","text":"<p>Given the coefficients in the spherical harmonic basis, finds the frames that correspond the most. Computation is unfortunately not direct: starting from the reference frame, we perform a gradient descent on the l2 distance between spherical harmonics coefficients.</p> <p>Also recomputes spherical harmonics coefficients to a perfect match. Uses the linearization of the exponential to approximate 9D rotations.</p> Warning <p>This algorithm is less precise and less efficient than <code>project_to_frame</code>. Use the latter instead.</p> <p>Parameters:</p> Name Type Description Default <code>sh</code> <code>Vec</code> <p>the 9 coefficients representing the frame in spherical harmonics basis</p> required <code>lr</code> <code>float</code> <p>Gradient descent learning rate. Defaults to 1.</p> <code>0.1</code> <code>grad_threshold (float,optional) </code> <p>Stoping criterion on the norm of the gradient. Defaults to 1e-4</p> required <code>dot_threshold (float,optional) </code> <p>Stoping criterion on the norm of the step. Defaults to 1e-6</p> required <code>max_iter</code> <code>int</code> <p>Maximum number of gradient steps. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <p>frame (scipy.spatial.transform.Rotation) : the obtained frame</p> <p>a (Vec) : the projected and updated spherical harmonics coefficients</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.rot_matrix_from_euler","title":"<code>rot_matrix_from_euler(w)</code>","text":"<p>Given three euler angles (XYZ), computes the 9x9 corresponding rotation matrix that performs the same rotation onto L4_SH coefficients</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Vec</code> <p>vector of size 3 representing three euler angles in convention XYZ.</p> required <p>Returns:</p> Name Type Description <code>L4_Operator</code> <code>L4_Operator</code> <p>a 9x9 matrix</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.rot_matrix_from_rotvec","title":"<code>rot_matrix_from_rotvec(v)</code>","text":"<p>Given a rotation in angle-axis form, computes the 9x9 corresponding rotation matrix that performs the same rotation onto L4_SH coefficients, defined as the exponential of the corresponding skew-symmetric matrix.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Vec</code> <p>a rotation axis vector where norm(v) represents the angle of rotation.</p> required <p>Returns:</p> Name Type Description <code>L4_Operator</code> <code>L4_Operator</code> <p>a 9x9 matrix</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.rotate_frame","title":"<code>rotate_frame(sh, r)</code>","text":"<p>Applies a rotation to a frame decomposed in L4_SH basis.</p> <p>Parameters:</p> Name Type Description Default <code>sh</code> <code>L4_SH</code> <p>coefficients of the frame</p> required <code>r</code> <code>Rotation | Vec</code> <p>rotation to be applied, either a scipy.Rotation object or a axis-angle representation.</p> required <p>Returns:</p> Name Type Description <code>L4_SH</code> <code>L4_SH</code> <p>the rotated frame coefficients</p>"},{"location":"utilities/spherical_harmonics/#mouette.geometry.SphericalHarmonics.skew_matrix_from_rotvec","title":"<code>skew_matrix_from_rotvec(w)</code>","text":"<p>Given a rotation in angle-axis form, computes the 9x9 corresponding skew-symmetric matrix</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Vec</code> <p>a rotation axis vector where norm(v) represents the angle of rotation.</p> required <p>Returns:</p> Name Type Description <code>L4_Operator</code> <code>L4_Operator</code> <p>a 9x9 matrix</p>"},{"location":"utilities/union_find/","title":"Union-Find","text":""},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind","title":"<code>UnionFind(elements=None)</code>","text":"<p>               Bases: <code>object</code></p> <p>Union-find disjoint sets datastructure.</p> <p>Original repository: https://github.com/deehzee/unionfind/blob/master/unionfind.py</p> <p>Union-find is a data structure that maintains disjoint set (called connected components or components in short) membership, and makes it easier to merge (union) two components, and to find if two elements are connected (i.e., belong to the same component).</p> <p>This implements the \"weighted-quick-union-with-path-compression\" union-find algorithm.  Only works if elements are immutable objects.</p> <p>Worst case for union and find: <code>(N + M log* N)</code>, with <code>N</code> elements and <code>M</code> unions. The function <code>log*</code> is the number of times needed to take <code>log</code> of a number until reaching 1. In practice, the amortized cost of each operation is nearly linear [1]_.</p> Terms <p>Component:     Elements belonging to the same disjoint set</p> <p>Connected:     Two elements are connected if they belong to the same component.</p> <p>Union:     The operation where two components are merged into one.</p> <p>Root:     An internal representative of a disjoint set.</p> <p>Find:     The operation to find the root of a disjoint set.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>None or container</code> <p>The initial list of elements.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>n_elts</code> <code>int</code> <p>Number of elements.</p> <code>n_comps</code> <code>int</code> <p>Number of distjoint sets or components.</p> <code>__len__</code> <p>Calling <code>len(uf)</code> (where <code>uf</code> is an instance of <code>UnionFind</code>) returns the number of elements.</p> <code>__contains__</code> <p>For <code>uf</code> an instance of <code>UnionFind</code> and <code>x</code> an immutable object, <code>x in uf</code> returns <code>True</code> if <code>x</code> is an element in <code>uf</code>.</p> <code>__getitem__</code> <p>For <code>uf</code> an instance of <code>UnionFind</code> and <code>i</code> an integer, <code>res = uf[i]</code> returns the element stored in the <code>i</code>-th index. If <code>i</code> is not a valid index an <code>IndexError</code> is raised.</p> <code>__setitem__</code> <p>For <code>uf</code> and instance of <code>UnionFind</code>, <code>i</code> an integer and <code>x</code> an immutable object, <code>uf[i] = x</code> changes the element stored at the <code>i</code>-th index. If <code>i</code> is not a valid index an <code>IndexError</code> is raised.</p> References <p>[1] http://algs4.cs.princeton.edu/lectures/</p>"},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind.add","title":"<code>add(x)</code>","text":"<p>Add a single disjoint element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>immutable object</p> required"},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind.component","title":"<code>component(x)</code>","text":"<p>Find the connected component containing the given element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>immutable object</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the given element is not found.</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>The component of x</p>"},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind.component_mapping","title":"<code>component_mapping()</code>","text":"<p>Return a dict mapping elements to their components.</p> <p>The returned dict has the following semantics</p> <pre><code>`elt -&gt; component containing elt`\n</code></pre> <p>If x, y belong to the same component, the comp(x) and comp(y) are the same objects (i.e., share the same reference). Changing comp(x) will reflect in comp(y).  This is done to reduce memory.</p> <p>But this behaviour should not be relied on.  There may be inconsistency arising from such assumptions or lack thereof.</p> <p>If you want to do any operation on these sets, use caution. For example, instead of</p> <pre><code>s = uf.component_mapping()[item]\ns.add(stuff)\n# This will have side effect in other sets\n</code></pre> <p>do <pre><code>s = set(uf.component_mapping()[item]) # or\ns = uf.component_mapping()[item].copy()\ns.add(stuff)\n</code></pre></p> <p>or <pre><code>s = uf.component_mapping()[item]\ns = s | {stuff}  # Now s is different\n</code></pre></p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dict with the semantics: <code>elt -&gt; component contianing elt</code>.</p>"},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind.components","title":"<code>components()</code>","text":"<p>Return the list of connected components.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of sets representing components</p>"},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind.connected","title":"<code>connected(x, y)</code>","text":"<p>Return whether the two given elements belong to the same component.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>immutable object</p> required <code>y</code> <code>Any</code> <p>immutable object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if x and y are connected, false otherwise.</p>"},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind.find","title":"<code>find(x)</code>","text":"<p>Find the root of the disjoint set containing the given element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>immutable object</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The (index of the) root.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the given element is not found.</p>"},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind.roots","title":"<code>roots()</code>","text":"<p>Return the set of roots of components</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>A set of elements</p>"},{"location":"utilities/union_find/#mouette.utils.unionfind.UnionFind.union","title":"<code>union(x, y)</code>","text":"<p>Merge the components of the two given elements into one.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>immutable object</p> required <code>y</code> <code>Any</code> <p>immutable object</p> required"},{"location":"utilities/utils/","title":"Geometry Utilities","text":""},{"location":"utilities/utils/#mouette.geometry.geometry.angle_2vec2D","title":"<code>angle_2vec2D(V1, V2)</code>","text":"<p>Angle between two 2D vectors</p> <p>Parameters:</p> Name Type Description Default <code>V1</code> <code>Vec</code> <p>first vector</p> required <code>V2</code> <code>Vec</code> <p>second vector</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the angle</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.angle_2vec3D","title":"<code>angle_2vec3D(V1, V2)</code>","text":"<p>Angle between two 3D vectors</p> <p>Parameters:</p> Name Type Description Default <code>V1</code> <code>Vec</code> <p>first vector</p> required <code>V2</code> <code>Vec</code> <p>second vector</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the angle</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.angle_3pts","title":"<code>angle_3pts(A, B, C)</code>","text":"<p>Angle ABC between three points</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>first point</p> required <code>B</code> <code>Vec</code> <p>central point</p> required <code>C</code> <code>Vec</code> <p>second point</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the angle</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.aspect_ratio","title":"<code>aspect_ratio(A, B, C)</code>","text":"<p>Computes the aspect ratio of triangle ABC, defined as the ratio between the circumradius to twice the inradius. This ratio equals 1 for equilateral triangle and goes to zero as the triangle gets close to degenerate.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>first point of the triangle</p> required <code>B</code> <code>Vec</code> <p>second point of the triangle</p> required <code>C</code> <code>Vec</code> <p>third point of the triangle</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the aspect ratio of triangle ABC</p> References <p>https://stackoverflow.com/a/10290011</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.circumcenter","title":"<code>circumcenter(v1, v2, v3)</code>","text":"<p>Circumcenter of the triangle formed by three points</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>Vec</code> <p>first point</p> required <code>v2</code> <code>Vec</code> <p>second point</p> required <code>v3</code> <code>Vec</code> <p>third point</p> required Warning <p>Circumcenter of triangle (v1,v2,v3) may not lay inside the triangle</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>coordinates of the circumcenter</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.cotan","title":"<code>cotan(A, B, C)</code>","text":"<p>cotangent of the angle \\(\\hat{ABC}\\)</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>point A</p> required <code>B</code> <code>Vec</code> <p>point B</p> required <code>C</code> <code>Vec</code> <p>point C</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the cotangent</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.cross","title":"<code>cross(A, B)</code>","text":"<p>Cross product of vectors A and B</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>Size 3 vector</p> required <code>B</code> <code>Vec</code> <p>Size 3 vector</p> required <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>cross product AxB</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.det_2x2","title":"<code>det_2x2(A, B)</code>","text":"<p>Computes a 2x2 determinant</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Union[complex, ndarray]</code> <p>first column vector. Can also be a complex number</p> required <code>B</code> <code>Union[complex, ndarray]</code> <p>second column vector. Can also be a complex number</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the determinant</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.det_3x3","title":"<code>det_3x3(*args)</code>","text":"<p>Computes a 3x3 using the rule of Sarrus</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Either a 3x3 numpy array representing a matrix, or 3 3x1 numpy array representing three column vectors</p> <code>()</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the determinant</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.distance","title":"<code>distance(A, B, which='l2')</code>","text":"<p>Distance between A and B. Three distances are implemented, the Euclidean distance l2, the Manhattan l1 distance of the l-infinity distance:</p> <p>l2: \\(\\sqrt{(B-A)^T(B-A)} = \\sqrt{\\sum_i (A_i - B_i)^2}\\)</p> <p>l1: \\(\\sum_i |A_i - B_i|\\)</p> <p>linf: \\(\\max_i |A_i - B_i|\\)</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>first point</p> required <code>B</code> <code>Vec</code> <p>second point</p> required <code>which</code> <code>str</code> <p>which norm to compute. Choices are \"l2\", \"l1\" and \"linf\". Defaults to \"l2\".</p> <code>'l2'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>distance</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.distance_to_segment2D","title":"<code>distance_to_segment2D(P, A, B)</code>","text":"<p>Computes, in the plane, the distance of point P to the segment [A;B]</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>Vec</code> <p>Query point in 2D</p> required <code>A</code> <code>Vec</code> <p>First segment extremity</p> required <code>B</code> <code>Vec</code> <p>Second segment extremity</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the euclidean distance from P to [A;B]</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.dot","title":"<code>dot(A, B)</code>","text":"<p>dot product \\(A^TB\\) between two vectors</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>first vector</p> required <code>B</code> <code>ndarray</code> <p>second vector</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>dot product</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.face_basis","title":"<code>face_basis(*f)</code>","text":"<p>Orthonormal basis of face Given three points A,B,C, returns a basis such that the first vector is along direction AB and third vector is normal to the plane ABC</p> <p>Parameters:</p> Name Type Description Default <code>*f</code> <p>points of the face, either on a list or not</p> <code>()</code> <p>Returns:</p> Type Description <p>Vec,Vec,Vec: an orthonormal 3D basis of the face</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.intersect_2lines2D","title":"<code>intersect_2lines2D(p1, d1, p2, d2)</code>","text":"<p>Computes the intersection of two lines in the plane</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Vec</code> <p>point on the first line</p> required <code>d1</code> <code>Vec</code> <p>direction vector of the first line</p> required <code>p2</code> <code>Vec</code> <p>point on the second line</p> required <code>d2</code> <code>Vec</code> <p>direction vector of the second line</p> required <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>the intersection point. None if lines are parallel</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.norm","title":"<code>norm(x, which='l2')</code>","text":"<p>Vector norm. Three norms are implemented, the Euclidean l2 norm, the l1 norm or the l-infinite norm:</p> <p>l2: $ \\sqrt{ \\sum_i v[i]^2 } $</p> <p>l1: $ \\sum_i |v[i]| $</p> <p>linf: $ \\max_i |v[i]| $</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>vector from which we compute the norm. Will be flattened if it has more than one dimension.</p> required <code>which</code> <code>str</code> <p>which norm to compute. Choices are \"l2\", \"l1\" and \"linf\". Defaults to \"l2\".</p> <code>'l2'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the vector's norm</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.project_to_plane","title":"<code>project_to_plane(P, N, orig)</code>","text":"<p>Projects vector P onto the plane of normal N and passing through point 'orig'</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>Vec</code> <p>query position to project</p> required <code>N</code> <code>Vec</code> <p>normal vector of the plane</p> required <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>P projected onto the plane</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.quad_area","title":"<code>quad_area(A, B, C, D)</code>","text":"<p>Area of the quad ABCD</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>first point</p> required <code>B</code> <code>Vec</code> <p>second point</p> required <code>C</code> <code>Vec</code> <p>third point</p> required <code>D</code> <code>Vec</code> <p>fourth point</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>area</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.sign","title":"<code>sign(x)</code>","text":"\\[\\text{sign}(x)=\\begin{cases}      0 \\text{ if } x=0 \\\\     1 \\text{ if } x&gt;0 \\\\     -1 \\text{ if } x&lt;0 \\end{cases}\\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>input number</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>x/|x| and 0 for x=0</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.sign0","title":"<code>sign0(x)</code>","text":"\\[\\text{sign0}(x)=\\begin{cases}      1 \\text{ if } x\\geqslant0 \\\\     -1 \\text{ if } x&lt;0 \\end{cases}\\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>input number</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>the sign of x</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.signed_angle_2vec3D","title":"<code>signed_angle_2vec3D(V1, V2, N)</code>","text":"<p>Signed angle between two vectors with orientation given by normal N</p> <p>Parameters:</p> Name Type Description Default <code>V1</code> <code>Vec</code> <p>First vector</p> required <code>V2</code> <code>Vec</code> <p>Second vector</p> required <code>N</code> <code>Vec</code> <p>reference normal direction</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the angle</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.signed_angle_3pts","title":"<code>signed_angle_3pts(A, B, C, N)</code>","text":"<p>Signed angle between three points ABC with orientation givne by normal N</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>first point</p> required <code>B</code> <code>Vec</code> <p>central point</p> required <code>C</code> <code>Vec</code> <p>second point</p> required <code>N</code> <code>Vec</code> <p>reference normal direction</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the angle</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.triangle_area","title":"<code>triangle_area(A, B, C)</code>","text":"<p>Area of 3D triangle ABC</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>first point</p> required <code>B</code> <code>Vec</code> <p>second point</p> required <code>C</code> <code>Vec</code> <p>third point</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>area</p>"},{"location":"utilities/utils/#mouette.geometry.geometry.triangle_area_2D","title":"<code>triangle_area_2D(A, B, C)</code>","text":"<p>Area of 2D triangle ABC</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Vec</code> <p>first point</p> required <code>B</code> <code>Vec</code> <p>second point</p> required <code>C</code> <code>Vec</code> <p>third point</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>area</p>"},{"location":"utilities/vectors/","title":"The Vector Class","text":""},{"location":"utilities/vectors/#mouette.geometry.vector.Vec","title":"<code>Vec</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>A simple class to manipulate vectors in mouette.  Basically, it inherits from a numpy array and implements some quality of life features for 2D and 3D vectors especially.</p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.x","title":"<code>x</code>  <code>property</code> <code>writable</code>","text":"<p>First coordinate of the vector</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p><code>vec[0]</code></p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.xy","title":"<code>xy</code>  <code>property</code>","text":"<p>First two coordinates of the vector</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray[float]: <code>vec[:2]</code></p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.y","title":"<code>y</code>  <code>property</code> <code>writable</code>","text":"<p>Second coordinate of the vector</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p><code>vec[1]</code></p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.z","title":"<code>z</code>  <code>property</code> <code>writable</code>","text":"<p>Third coordinate of the vector</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p><code>vec[3]</code></p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.X","title":"<code>X()</code>  <code>classmethod</code>","text":"<p>The [1,0,0] vector</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>[1,0,0]</p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.Y","title":"<code>Y()</code>  <code>classmethod</code>","text":"<p>The [0,1,0] vector</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>[0,1,0]</p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.Z","title":"<code>Z()</code>  <code>classmethod</code>","text":"<p>The [0,0,1] vector</p> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>[0,0,1]</p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.dot","title":"<code>dot(other)</code>","text":"<p>Dot product between two vectors:</p> <p>$ a \\cdot b = \\sum_i a[i]b[i]$</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vec</code> <p>other vector to dot with</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the dot product</p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.from_complex","title":"<code>from_complex(c)</code>  <code>classmethod</code>","text":"<p>2D vector from complex number</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>complex</code> required <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p><code>Vec(c.real, c.imag)</code></p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.norm","title":"<code>norm(which='l2')</code>","text":"<p>Vector norm. Three norms are implemented: the Euclidean l2 norm, the l1 norm or the l-infinite norm:</p> <p>l2 : $ \\sqrt{ \\sum_i v[i]^2 } $</p> <p>l1 : $ \\sum_i |v[i]| $</p> <p>linf : $ \\max_i |v[i]| $</p> <p>Parameters:</p> Name Type Description Default <code>which</code> <code>str</code> <p>which norm to compute. Choices are \"l2\", \"l1\" and \"linf\". Defaults to \"l2\".</p> <code>'l2'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the vector's norm</p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.normalize","title":"<code>normalize(which='l2')</code>","text":"<p>Normalizes the vector to have unit norm.</p> <p>Parameters:</p> Name Type Description Default <code>which</code> <code>str</code> <p>which norm to compute. Choices are \"l2\", \"l1\" and \"linf\". Defaults to \"l2\".</p> <code>'l2'</code>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.normalized","title":"<code>normalized(vec, which='l2')</code>  <code>staticmethod</code>","text":"<p>Computes and returns a normalized vector of the input vector <code>vec</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>Vec</code> <p>the input vector</p> required <code>which</code> <code>str</code> <p>which norm to compute. Choices are \"l2\", \"l1\" and \"linf\". Defaults to \"l2\".</p> <code>'l2'</code> <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code> <p>the normalized vector</p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.outer","title":"<code>outer(other)</code>","text":"<p>Outer product between two vectors:</p> <p>\\(a \\otimes b = c \\in \\mathbb{R}^{n \\times n}\\) such that \\(c[i,j] = a[i]b[j]\\).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vec</code> <p>the second vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.array: an array of shape (n,n)</p>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.random","title":"<code>random(n)</code>  <code>classmethod</code>","text":"<p>Generates a random vector of size <code>n</code> with coefficients sampled uniformly and independently in [0;1)</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>size</p> required <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code>"},{"location":"utilities/vectors/#mouette.geometry.vector.Vec.zeros","title":"<code>zeros(n)</code>  <code>classmethod</code>","text":"<p>Generates a vector of size <code>n</code> full of zeros.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>size</p> required <p>Returns:</p> Name Type Description <code>Vec</code> <code>Vec</code>"}]}